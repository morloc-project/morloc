// C++ header sourced by morloc script
#pragma one

#include <algorithm>
#include <cstdint>
#include <fstream>
#include <iostream>
#include <map>
#include <string>
#include <tuple>
#include <vector>

// Code adapted from that generated by Perplexity using the Morloc type
// signatures as prompts

// Types for clarity
using Str = std::string;
using FASTQRecord = std::tuple< std::tuple<Str, Str>, Str >;
using namespace std;

// Struct to hold the trimming configuration
struct Config {
    int minLength;
    int minQuality;
};

// Read a FASTQ file into a vector of tuples
vector<FASTQRecord> readFASTQ(const Str& filename) {
    ifstream fin(filename);
    vector<FASTQRecord> result;
    if (!fin) {
        cerr << "Cannot open file: " << filename << endl;
        return result;
    }
    Str header, seq, plus, qual;
    while (getline(fin, header)) {
        // FASTQ files: 4 lines per record
        if (!getline(fin, seq)) break;
        if (!getline(fin, plus)) break;
        if (!getline(fin, qual)) break;
        // Strip '@' from header if present
        if (!header.empty() && header[0] == '@') header = header.substr(1);
        // Pair (header, quality), then sequence
        result.push_back(
            make_tuple(
                make_tuple(header, qual),
                seq
            )
        );
    }
    return result;
}

// Write a list of (header, sequence) to FASTA file
int writeFASTA(const Str& filename, const std::vector< std::tuple<Str, Str> >& records) {
    std::ofstream fout(filename);
    if (!fout) {
        std::cerr << "Cannot open file for writing: " << filename << std::endl;
        return 1;
    }
    for (const auto& rec : records) {
        fout << ">" << std::get<0>(rec) << "\n";
        fout << std::get<1>(rec) << "\n";
    }
    fout.close();
    return 0;
}


// Helper to convert ASCII "Fred" (Phred+33) to score
inline uint8_t fredScore(char c) {
    return static_cast<uint8_t>(c) - 33;
}

// Trim low-quality bases at both ends
std::string trimRead(
    const Config& config,
    const std::string& qualities,
    const std::string& sequence
) {
    size_t n = sequence.size();
    if (qualities.size() != n) return "";

    size_t left = 0, right = n;
    while (left < n && fredScore(qualities[left]) < config.minQuality) ++left;
    while (right > left && fredScore(qualities[right-1]) < config.minQuality) --right;

    if (right <= left) return "";

    std::string trimmed_seq = sequence.substr(left, right - left);

    return trimmed_seq;
}
