-- Test do-notation, which desugars to suspend + let + force:
--   do { x <- e1; e2; return e3 }  -->  { let x = !e1 in let _ = !e2 in e3 }
--
-- Cases tested:
--   1. doReturn: do-block with only return (trivial, no effects)
--   2. doBind: bind a forced thunk to a variable
--   3. doBare: bare statement forced and discarded
--   4. doChain: multiple binds feeding into each other
--   5. doMixed: interleaving bare statements and binds
-- sideEffect :: Int -> {Int} captures the side effect in the type.
-- Each sideEffect call prints "EVAL <input>" to stderr and returns input * 2.

module main (doReturn, doBind, doBare, doChain, doMixed)

import root-cpp

source Cpp from "foo.hpp" ("sideEffect", "add")

type Cpp => Int = "int"

sideEffect :: Int -> {Int}
add :: Int -> Int -> Int

-- do-block with only return: desugars to !{42} = 42
doReturn :: Int
doReturn = !do
    return 42

-- do-block with bind: x <- sideEffect 5 forces thunk, binds x = 10
-- then return (add x 1) = 11
doBind :: Int
doBind = !do
    x <- sideEffect 5
    return (add x 1)

-- do-block with bare statement: forces and discards result
-- sideEffect 3 called (prints "EVAL 3"), result discarded, returns 42
doBare :: Int
doBare = !do
    sideEffect 3
    return 42

-- chained binds: result of first feeds into second
-- sideEffect 3 -> "EVAL 3", x = 6
-- sideEffect 6 -> "EVAL 6", y = 12
-- add 6 12 = 18
doChain :: Int
doChain = !do
    x <- sideEffect 3
    y <- sideEffect x
    return (add x y)

-- mix of bare statements and binds
-- sideEffect 1 -> "EVAL 1", discarded
-- sideEffect 5 -> "EVAL 5", x = 10
-- sideEffect 10 -> "EVAL 10", discarded
-- add 10 1 = 11
doMixed :: Int
doMixed = !do
    sideEffect 1
    x <- sideEffect 5
    sideEffect x
    return (add x 1)
