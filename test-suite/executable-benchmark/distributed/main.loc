module m (foo)

type Py => Int = "int"
type Py => Real = "float"
type Py => Tuple2 a b = "tuple" a b
type Py => List a = "list" a

source Py from "foo.py" ("nTrials", "mean", "sd", "simulate")

simulate :: Int -> [Real]
mean :: [Real] -> Real
sd :: [Real] -> Real

-- multi-threaded program for running a random process many times on the same input
nTrials a b :: Int -> a -> (a -> b) -> [b]

foo :: Int -> Int -> (Real, Real)
foo n size = (mean means, sd means)
  where
  means = nTrials n size (small:mean . simulate)

-- -- case 1: applications
-- f1 x = small:foo x
--
-- -- case 2: compositions
-- f1 = small:foo . bar
--
-- -- non-case: lambdas, instead bind the top named function, there always is one
-- f3 = (\y -> small:foo (bar y))
--
-- -- basically, we are always binding directly to a variable name
--
-- -- what about this? the label should travel with bar, so `f4 = small:foo`
-- bar = small:foo
-- f4 = bar
