-- QA:
--  * How are functions passed? They can't be serialized. Calls are written
--    into the generate code.
-- 
--  * What if a language cannot pass functions as arguments?
-- 
--  * What about OOP methods? Styles. Though support is not finished yet.
-- 
--  * What about mutability? Effects and styles.
-- 
--  * What about laziness? No solution in the works yet. For now, everything is
--    eager between languages and potentially lazy within. This violates the
--    agnostic principle. Perhaps I could add type-level syntax for laziness?
-- 
--  * How are arguments passed (i.e., pass-by-reference versus pass-by-value)?
--    Currently, pass-by-value between languages (serialization to JSON), and
--    variable within languages.
-- 
--  * What about `const` keywords and other random hints different languages add?
--    This is challenging. The styles is intended to address that partially.


-- import packages from central morloc hub OR the local module IF in module path
import bio.io
-- -- import from a special namespace
-- import alice:bio.io
-- -- import from a github repo
-- import alice@github:bio.io

import bio.io (read_fasta, write_fasta)
import bio.tree (NelTree)
import bio.algo (nj_tree as build_tree, foo_msa as align)
import bio.algo (nj_tree as build_tree, foo_msa as align)

import base (with_vals, seq, toSnd, map)


export analysis

augment :: (a -> b) -> [a] -> [(a, b)]
augment f xs = map (couple_right f) xs 

-- type Filename = Str
-- type Tag = Str
-- type Jsonpath = [Str]
-- type Identifier = Str
-- type Sequence = Str

analysis :: Filename -> ()
analysis gisaid_file = fold seq
      [ write_tree "tree.newick" tree
      , view_tree "tree.pdf" tree,
      ]
    where
        tree = tree_of build_tree alignment

        alignment = with_vals align (
            augment lookup_sequence (
                json_list_filter_map parse_record select_record gisaid_file ["x", "y"]

                jsonListFilterMap parseRecord selectRecord gisaidFile ["x", "y"]
            )
        )


-- filter a large file, create raw strings for individual elements
json_list_filter_map
    :: (String -> a)  -- Convert an element string
    -> (a -> Bool)    -- Decide whether to keep the parsed object
    -> Filename       -- Path to the JSON file
    -> [Tag]          -- Path to the array in the JSON structure
    -> [a]            -- Final list of things of interest

lookup_sequence :: Identifier -> Sequence

align xs =
    seq (seq
        (write_fasta (map (with_fst show) (enumerate xs)) tmpfile)
        (map snd (read_fasta (third (shell_cmd ["mafft", tmpfile]))))
    )
        (rm tmpfile)
    where
        tmpfile = "tmp.fa"

-- -- Where [a] has length 1 or 0
-- pack_maybe   :: pack   => [a] -> Maybe a
-- unpack_maybe :: unpack => Maybe a -> [a]
--
-- -- Where either [a] or [b] is empty and the other has length 1
-- pack_either   :: pack   => ([a], [b]) -> Either a b
-- unpack_either :: unpack => Either a b -> ([a], [b])
