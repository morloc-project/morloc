-- QA:
--  * How are functions passed? They can't be serialized. Calls are written
--    into the generate code.
-- 
--  * What if a language cannot pass functions as arguments?
-- 
--  * What about OOP methods? Styles. Though support is not finished yet.
-- 
--  * What about mutability? Effects and styles.
-- 
--  * What about laziness? No solution in the works yet. For now, everything is
--    eager between languages and potentially lazy within. This violates the
--    agnostic principle. Perhaps I could add type-level syntax for laziness?
-- 
--  * How are arguments passed (i.e., pass-by-reference versus pass-by-value)?
--    Currently, pass-by-value between languages (serialization to JSON), and
--    variable within languages.
-- 
--  * What about `const` keywords and other random hints different languages add?
--    This is challenging. The styles is intended to address that partially.


import bio.io (readFasta, writeFasta)
import bio.tree (NelTree)
import bio.algo (nj_tree as buildTree, foo_msa as align)

import base (with_vals, seq, couple_right, map)


export analysis

augment :: (a -> b) -> [a] -> [(a, b)]
augment f xs = map (couple_right f) xs 

-- type Filename = Str
-- type Tag = Str
-- type Jsonpath = [Str]
-- type Identifier = Str
-- type Sequence = Str

analysis :: Filename -> ()
analysis gisaidFile = fold seq
      [ writeTree "tree.newick" tree
      , viewTree "tree.pdf" tree,
      ]
    where
        tree = treeOf buildTree alignment

        alignment = with_vals align (
            augment lookupSequence (
                jsonListFilterMap parseRecord selectRecord gisaidFile ["x", "y"]
            )
        )


-- filter a large file, create raw strings for individual elements
jsonListFilterMap
    :: (String -> a)  -- Convert an element string
    -> (a -> Bool)    -- Decide whether to keep the parsed object
    -> Filename       -- Path to the JSON file
    -> [Tag]          -- Path to the array in the JSON structure
    -> [a]            -- Final list of things of interest

lookupSequence :: Identifier -> Sequence

align xs =
    seq (seq
        (writeFasta (map (with_fst show) (enumerate xs)) tmpfile)
        (map snd (readFasta (third (shellCmd ["mafft", tmpfile]))))
    )
        (rm tmpfile)
    where
        tmpfile = "tmp.fa"

-- -- Where [a] has length 1 or 0
-- packMaybe   :: pack   => [a] -> Maybe a
-- unpackMaybe :: unpack => Maybe a -> [a]
--
-- -- Where either [a] or [b] is empty and the other has length 1
-- packEither   :: pack   => ([a], [b]) -> Either a b
-- unpackEither :: unpack => Either a b -> ([a], [b])
