module flucase (plotClasses, classifyByDate, plotCladeTree)

import types (Str, Int, Filename, Real, Unit, Map, Tuple2)
import json (JsonObj)

type Accession = Str
type Clade = Str 
type Sequence = Str
type EntrezQuery = Str
type Date = Str
type Query = Str

import bio.algo (upgma)

import bio.tree
  ( RootedTree
  , treeBy   -- treeBy :: ([b] -> Tree n e Int) -> [(l, b)] -> Tree n e l
  , pullNode -- pull :: (l -> n') -> ([n'] -> n') -> Tree n e l -> Tree n' e l
  , push
  , mapLeaf
  )

import bio.db
  ( searchEntrez as fetchIds                   -- fetchIds :: EntrezSearchConfig -> Query -> [Str]
  , nucleotideAccessionToJson as fetchRecords  -- fetchIdRecords :: [Str] -> [Str]
  , EntrezSearchConfig
  , EntrezFetchConfig
  )

import base
  ( id
  , const
  , at
  , map
  , ne
  , fst
  , snd
  , concat
  , filter
  , shard
  , gt
  , eq
  , head
  , take
  , ifelse
  , branch
  , join
  , paste
  , keys
  , size
  , onFst
  , sleep
  , unique
  , withSnds
  , readMap
  )


source Py from "entrez_helpers.py"
  ( "parseRecord"
  , "labelRef"
  , "setLeafName"
  )

parseRecord :: JsonObj -> (JsonObj, Sequence)
labelRef :: Map Accession Clade -> JsonObj -> (JsonObj, Clade)
setLeafName :: (JsonObj, Sequence) -> Str

source R from "plot-tree.R" ("plotTree")

plotTree :: Filename -> RootedTree n Real Str -> ()

record FluConfig = FluConfig
  { mindate :: Date
  , maxdate :: Date
  , reffile :: Filename
  , treefile :: Filename
  , query :: Str
  , email :: Str
  }
record Py => FluConfig = "dict"
record R => FluConfig = "list"


plotClasses :: FluConfig -> ()
plotClasses config = plotCladeTree config (classifyByDate config)


plotCladeTree :: FluConfig -> RootedTree Str e (a, Clade) -> ()
plotCladeTree config = plotTree config@treefile . mapLeaf setLeafName 


classifyByDate :: FluConfig -> RootedTree Str e (a, Clade)
classifyByDate = classify . treeBy upgma . searchEntrez


searchEntrez :: FluConfig -> [((JsonObj, Clade), Sequence)]
searchEntrez config =
  ( map (onFst (labelRef refmap))
  . concat
  . map ( map parseRecord
        . sleep 1.0
        . fetchRecords fetchConfig
        )
  . shard 30
  . join (keys refmap)
  . fetchIds searchConfig
  ) config@query
  where
    searchConfig =
      { email = config@email
      , db = "nuccore"
      , mindate = config@mindate
      , maxdate = config@maxdate
      , retmax = 1000
      }
    fetchConfig = { email = config@email }
    refmap = readMap config@reffile
    query = config@query


classify :: RootedTree n e (a, Clade) -> RootedTree Str e (a, Clade)
classify
  = push id passClade setLeaf
  . pullNode snd pullClade where

  passClade parent edge child = (edge, ifelse (eq 0 (size child)) parent child)

  -- setLeaf parent edge leaf = (edge, { accession = leaf@accession, clade = parent })
  setLeaf parent edge leaf = (edge, (fst leaf, parent))

  pullClade xs
    = branch (eq 1 . size) head (const "") seenClades
    where
      seenClades = ( unique
                   . filter (ne 0 . size)
                   ) xs
