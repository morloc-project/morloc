module flucase (analysis)

import conventions (Str, Int, Filename, Real, Unit, Map, Tuple2)
import json (JsonObj)

type Accession = Str
type Clade = Str 
type Sequence = Str
type EntrezQuery = Str
type Date = Str
type Query = Str

import bio.algo (upgma)

import bio.tree
  ( RootedTree
  , treeBy   -- treeBy :: ([b] -> Tree n e Int) -> [(l, b)] -> Tree n e l
  , pullNode -- pull :: (l -> n') -> ([n'] -> n') -> Tree n e l -> Tree n' e l
  , push
  , mapLeaf
  )

import bio.db
  ( searchEntrez as fetchIds                   -- fetchIds :: EntrezSearchConfig -> Query -> [Str]
  , nucleotideAccessionToJson as fetchRecords  -- fetchIdRecords :: [Str] -> [Str]
  , EntrezSearchConfig
  , EntrezFetchConfig
  )

import base
  ( id
  , const
  , at
  , map
  , ne
  , fst
  , snd
  , concat
  , filter
  , shard
  , gt
  , eq
  , head
  , take
  , ifelse
  , branch
  , join
  , paste
  , keys
  , length
  , lengthS
  , onFst
  , sleep
  , unique
  , withSnds
  , readMap
  )


source Py from "entrez_helpers.py"
  ( "parseRecord"
  , "labelRef"
  , "setLeafName"
  )

parseRecord :: JsonObj -> (JsonObj, Sequence)
labelRef :: Map Accession Clade -> JsonObj -> (JsonObj, Clade)
setLeafName :: (JsonObj, Sequence) -> Str

source R from "plot-tree.R" ("plotTree")

plotTree :: Filename -> RootedTree n Real Str -> ()


analysis :: Date -> Date -> Filename -> Filename -> ()
analysis mindate maxdate reffile treefile
  = ( plotTree treefile
    . mapLeaf setLeafName
    . classify -- Tree string double meta
    . treeBy upgma
    . search fetchConfig searchConfig refmap
    ) query
  where
    query = "Influenza+A+Virus[Organism]+H3N2[ALL]+HA[ALL]"
    email = "zbwrnz@gmail.com"
    searchConfig =
      { email = email
      , db = "nuccore"
      , mindate = mindate
      , maxdate = maxdate
      , retmax = 1000
      }
    fetchConfig = { email = email }
    refmap = readMap reffile


search :: EntrezFetchConfig -> EntrezSearchConfig -> Map Accession Clade -> Query
       -> [((JsonObj, Clade), Sequence)]
search fetchConfig searchConfig refs query =
  ( map (onFst (labelRef refs))
  . concat
  . map ( map parseRecord
        . sleep 1.0
        . fetchRecords fetchConfig
        )
  . shard 30
  . join (keys refs)
  . take 50
  . fetchIds searchConfig
  ) query


-- classify :: RootedTree n e (a, Clade) -> RootedTree Str e (a, Clade)
classify
  = push id passClade setLeaf
  . pullNode snd pullClade where

  passClade parent edge child = (edge, ifelse (eq 0 (lengthS child)) parent child)

  -- setLeaf parent edge leaf = (edge, { accession = leaf@accession, clade = parent })
  setLeaf parent edge leaf = (edge, (fst leaf, parent))

  pullClade xs
    = branch (eq 1 . length) head (const "") seenClades
    where
      seenClades = ( unique
                   . filter (ne 0 . lengthS)
                   ) xs
