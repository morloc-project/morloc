export analysis

type Filename = Str 
type Accession = Str
type Clade = Str 
type StrainName = Str
type Sequence = Str
type EntrezQuery = Str
type Label = Str
type Date = Str
type Query = Str

record Meta = Meta
  { accession :: Accession
  , clade :: Clade
  }

record EntrezSearchConfig = EntrezSearchConfig
  { email :: Str
  , db :: Str  
  , mindate :: Str
  , maxdate :: Str
  , retmax :: Int 
  }

import bio.algo
  ( fooMsa as align    -- align :: [Sequence] -> [Sequence]
  , njTree as treeify  -- treeify :: [Sequence] -> Tree Int Real Int
  )

import bio.tree
  ( Tree
  , treeBy             -- treeBy :: ([b] -> Tree n e Int) -> [(l, b)] -> Tree n e l
  , pull               -- pull :: (l -> n') -> ([n'] -> n') -> Tree n e l -> Tree n' e l
  , mapChildWithParent -- mapChildWithParent :: (n -> n') -> (n' -> n -> n') -> Tree n e l -> Tree n' e l
  )

import bio.db
  ( searchEntrez as fetchIds                    -- fetchIds :: EntrezSearchConfig -> Query -> [Str]
  , nucleotideAccessionToXml as fetchIdRecords  -- fetchIdRecords :: [Str] -> [Str]
  )

import core
  ( at        -- at :: [a] -> Int -> a
  , shard     -- shard :: Int -> [a] -> [[a]]
  , elem      -- elem :: a -> [a] -> Bool
  , fst       -- fst :: (a, b) -> a
  , gt        -- gt :: Int -> Int -> Bool
  , eq        -- eq :: Int -> Int -> Bool
  , head      -- head :: [a] -> a
  , ifelse    -- ifelse :: Bool -> a -> a -> a
  , join      -- join :: [a] -> [a] -> [a]
  , keys      -- keys :: Map a b -> [a]
  , length    -- length :: [a] -> Int
  , lookup    -- lookup :: k -> [(k, v)] -> v
  , onFst     -- onFst :: (a -> a') -> (a, b) -> (a', b)
  , sleep     -- sleep :: Real -> a -> a
  , snd       -- snd :: (a, b) -> b
  , strLength -- strLength :: Str -> Int
  , unique    -- unique :: [a] -> [a]
  , withVals  -- withVals :: ([a] -> [b]) -> [(c, a)] -> [(c, b)]
  , readMap   -- readMap :: Filename -> Map key val
  )

source Py from "analysis-functions.py"
  ( "parseRecord"   -- parseRecord :: Str -> (Meta, Sequence)
  , "labelRef"      -- labelRef :: Map Accession Clade -> Meta -> Meta
  , "plotTree"      -- plotTree :: Filename -> Tree n Real Meta -> ()
  )

analysis :: Date -> Date -> Filename -> Filename -> ()
analysis mindate maxdate reffile treefile
  = ( plotTree treefile
    . classify
    . treeBy treeify
    . withVals align  -- TODO: rethink this ... this is rather particular
    . search config refmap
    ) query
  where
    query = "Influenza+A+Virus[Organism]+H3N2[ALL]+HA[ALL]"
    config = { email = "weena@mlang.com"
             , db = "nuccore"
             , mindate = mindate
             , maxdate = maxdate
             , retmax = 1000
             }
    refmap = readMap reffile


search :: EntrezSearchConfig -> Map Accession Clade -> Query -> [(Meta, Sequence)]
search config refs query =
  ( map (onFst (labelRef refs))
  . concat
  . map ( map parseRecord
        . sleep 1.0
        . fetchRecords
        )
  . shard 100
  . join (keys refs)
  . fetchIds config
  ) query


classify = push (pull pullLeaf pullClade) where
  pullLeaf :: Meta -> Clade
  pullLeaf leaf = "asdf" -- leaf@clade

  pullClade :: [Clade] -> Clade
  pullClade xs
    = ifelse (eq (length seenClades) 1)
             (head seenClades) ""
    where
      seenClades = ( unique
                   . filter (\ x -> gt (strLength x) 0)
                   ) xs

  push = mapChildWithParent id (\ p c -> ifelse (eq c "") p c)
