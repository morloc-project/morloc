export align
export analysis
export at
export childrenOf
export chunks
export elem
export fetchIdRecords
export fst
export gt
export head
export ifelse
export join
export length
export longestORF
export lookup
export mapLeafs
export nodes
export parseRecord
export pull
export readFasta
export fetchIds
export sleep
export snd
export strLength
export translate
export treeify
export unique
export annTree

type Filename = Str 
type Accession = Str
type Clade = Str 
type StrainName = Str
type Sequence = Str
type EntrezQuery = Str
type Label = Str
type Date = Str
type Query = Str


record Meta = Meta
  { accession :: Accession
  , clade :: Clade
  }


record EntrezSearchConfig = EntrezSearchConfig
  { email :: Str
  , db :: Str  
  , mindate :: Str
  , maxdate :: Str
  , retmax :: Int 
  }


-- import bio.io (readFasta, writeFasta)
-- import bio.tree (Tree, treeOf, viewTree)
-- import bio.algo (njTree as treeify, fooMsa as align)
-- import bio.db (searchEntrez as fetchIds, nucleotideAccessionToXml)
-- import bio.util (chunks, sleep)

align :: [Sequence] -> [Sequence]
annTree :: ([b] -> Tree n e Int) -> [(l, b)] -> Tree n e l
at :: [a] -> Int -> a
childrenOf :: Tree n e l -> n -> [l]
chunks :: Int -> [a] -> [[a]]
elem :: a -> [a] -> Bool
fetchIdRecords :: [Str] -> [Str]
fetchIds :: EntrezSearchConfig -> Query -> [Str]
fst :: (a, b) -> a
gt :: Int -> Int -> Bool
head :: [a] -> a
ifelse :: Bool -> a -> a -> a
join :: [a] -> [a] -> [a]
keys :: Map a b -> [a]
labelRef :: Map Accession Clade -> Meta -> Meta
length :: [a] -> Int
longestORF :: Sequence -> Sequence
lookup :: k -> [(k, v)] -> v
mapLeafs :: (l -> l') -> Tree n e l -> Tree n e l'
nodes :: Tree n e l -> [n]
onFst :: (a -> a') -> (a, b) -> (a', b) 
parseRecord :: Str -> (Meta, Sequence)
pull :: (l -> n') -> ([n'] -> n') -> Tree n e l -> Tree n' e l
readFasta :: Filename -> [(Str, Sequence)]
readMap :: Filename -> Map key val
sleep :: Real -> a -> a
snd :: (a, b) -> b
strLength :: Str -> Int
translate :: Sequence -> Sequence
treeify :: [Sequence] -> Tree Int Real Int
unique :: [a] -> [a]
withVals :: ([a] -> [b]) -> [(c, a)] -> [(c, b)]


analysis :: Date -> Date -> Filename -> Filename -> ()
analysis mindate maxdate reffile treefile
  = ( plotTree treefile
    . classify
    . annTree treeify
    . withVals align
    . search config refmap
    ) query
  where
    query = "Influenza+A+Virus[Organism]+H3N2[ALL]+HA[ALL]"
    config = { email = "weena@mlang.com"
             , db = "nuccore"
             , mindate = mindate
             , maxdate = maxdate
             , retmax = 1000
             }
    refmap = readMap reffile


classify = push (pull pullLeaf pullClade) where
  pullLeaf :: Meta -> Clade
  pullLeaf leaf = "asdf" -- leaf@clade

  pullClade :: [Clade] -> Clade
  pullClade xs
    = ifelse (eq (length seenClades) 1)
             (head seenClades) ""
    where
      seenClades = ( unique
                   . filter (\ x -> gt (strLength x) 0)
                   ) xs

  push = mapPC id (\ p c -> ifelse (eq c "") p c)


search :: EntrezSearchConfig -> Map Accession Clade -> Query -> [(Meta, Sequence)]
search config refs query =
  ( map (onFst (labelRef refs))
  . concat
  . map ( map parseRecord
        . sleep 1.0
        . fetchRecords
        )
  . chunks 100
  . join (keys refs)
  . fetchIds config
  ) query
