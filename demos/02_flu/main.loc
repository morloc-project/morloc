-- QA:
--  * How are functions passed? They can't be serialized. Calls are written
--    into the generate code.
-- 
--  * What if a language cannot pass functions as arguments?
-- 
--  * What about OOP methods? Styles. Though support is not finished yet.
-- 
--  * What about mutability? Effects and styles.
-- 
--  * What about laziness? No solution in the works yet. For now, everything is
--    eager between languages and potentially lazy within. This violates the
--    agnostic principle. Perhaps I could add type-level syntax for laziness?
-- 
--  * How are arguments passed (i.e., pass-by-reference versus pass-by-value)?
--    Currently, pass-by-value between languages (serialization to JSON), and
--    variable within languages.
-- 
--  * What about `const` keywords and other random hints different languages add?
--    This is challenging. The styles is intended to address that partially.


-- import packages from central morloc hub OR the local module IF in module path
-- import bio.io
-- -- import from a special namespace
-- import alice:bio.io
-- -- import from a github repo
-- import alice@github:bio.io

import bio.io (readFasta, writeFasta)
import bio.tree (NelTree, treeOf, viewTree)
import bio.algo (njTree as tree, fooMsa as align)
import bio.db (searchEntrez, nucleotideAccessionToXml)

record VirusEntry = VirusEntry
    { accession :: Str
    , strain :: Str
    , date :: Str
    , host :: Str
    , location :: Str
    , spike :: Str
    }

accession :: VirusEntry -> Str
accession x = x.accession

spike :: VirusEntry -> Str
spike x = x.spike

parseEntrezNucleotideXml :: Str -> VirusEntry

retrieve = concat
         . map ( sleep 1
               . map parseEntrezNucleotideXml
               . cache (md5sum . join) nucleotideAccessionToXml
               )
         . chunks 1000
         . sort
         . searchEntrez

makeTree xs = mapLeaf (at xs)
            . cache (md5sum . join . map snd) tree
            . cache (md5sum . join . map accession) (align . map spike)

result = sampleTree
       . makeTree
       . retrieve "Influenza+A+Virus[Organism]" "2022/01" "2022/12"


import base (withVals, seq, toSnd, map)

gbkToSeq :: GenBankRecord -> Str

export analysis

augment :: (a -> b) -> [a] -> [(a, b)]
augment f xs = map (coupleRight f) xs 



fetch :: Conditions -> [VirusEntry]


partitionTree = mapLeafs (toSnd . regexCapture "(human|swine)")

subsamplePartitionedTree :: 

subsample
    :: (NelTree n e l -> NelTree n e (l, Str))
    -> (NelTree n e l2 -> NelTree n e l2)
    -> NelTree n e l -> NelTree n e l


-- fetch
-- align
-- makeTree
-- subsample
-- view
-- stats


-- getCovid :: Str -> [(MetaData, Str)]
--
-- -- type Filename = Str
-- -- type Tag = Str
-- -- type Jsonpath = [Str]
-- -- type Identifier = Str
-- -- type Sequence = Str
--
-- analysis :: Filename -> ()
-- analysis gisaidFile = fold seq
--       [ writeTree "tree.newick" tree
--       , viewTree "tree.pdf" tree,
--       ]
--     where
--         tree = treeOf buildTree alignment
--
--         alignment = withVals align (
--             augment lookupSequence (
--                 jsonListFilterMap parseRecord selectRecord gisaidFile ["x", "y"]
--                 jsonListFilterMap parseRecord selectRecord gisaidFile ["x", "y"]
--             )
--         )
--
--
-- -- filter a large file, create raw strings for individual elements
-- jsonListFilterMap
--     :: (String -> a)  -- Convert an element string
--     -> (a -> Bool)    -- Decide whether to keep the parsed object
--     -> Filename       -- Path to the JSON file
--     -> [Tag]          -- Path to the array in the JSON structure
--     -> [a]            -- Final list of things of interest
--
-- lookupSequence :: Identifier -> Sequence
--
-- align xs =
--     seq (seq
--         (writeFasta (map (withFst show) (enumerate xs)) tmpfile)
--         (map snd (readFasta (third (shellCmd ["mafft", tmpfile]))))
--     )
--         (rm tmpfile)
--     where
--         tmpfile = "tmp.fa"
--
-- -- -- Where [a] has length 1 or 0
-- -- pack_maybe   :: pack   => [a] -> Maybe a
-- -- unpack_maybe :: unpack => Maybe a -> [a]
-- --
-- -- -- Where either [a] or [b] is empty and the other has length 1
-- -- pack_either   :: pack   => ([a], [b]) -> Either a b
-- -- unpack_either :: unpack => Either a b -> ([a], [b])
