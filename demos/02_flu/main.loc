module flucase (classify, search, analysis)

type Filename = Str 
type Accession = Str
type Clade = Str 
type StrainName = Str
type Sequence = Str
type EntrezQuery = Str
type Label = Str
type Date = Str
type Query = Str

type Py Filename = "str"
type Py Accession = "str"
type Py Clade = "str"
type Py StrainName = "str"
type Py Sequence = "str"
type Py EntrezQuery = "str"
type Py Label = "str"
type Py Date = "str"
type Py Query = "str"

type Cpp Filename = "std::string" 
type Cpp Accession = "std::string"
type Cpp Clade = "std::string" 
type Cpp StrainName = "std::string"
type Cpp Sequence = "std::string"
type Cpp EntrezQuery = "std::string"
type Cpp Label = "std::string"
type Cpp Date = "std::string"
type Cpp Query = "std::string"

record Meta = Meta
  { accession :: Accession
  , clade :: Clade
  }

record Py Meta = "dict"
  { accession :: "str"
  , clade :: "str"
  }

record Cpp Meta = "struct"
  { accession :: "std::string"
  , clade :: "std::string"
  }


record EntrezSearchConfig = EntrezSearchConfig
  { email :: Str
  , db :: Str
  , mindate :: Str
  , maxdate :: Str
  , retmax :: Int
  }

import bio.algo
  ( align    -- align :: [Sequence] -> [Sequence]
  , nj as treeify  -- treeify :: [Sequence] -> Tree Int Real Int
  )

import bio.tree
  ( treeBy             -- treeBy :: ([b] -> Tree n e Int) -> [(l, b)] -> Tree n e l
  , pullNode           -- pull :: (l -> n') -> ([n'] -> n') -> Tree n e l -> Tree n' e l
  , mapChildWithParent -- mapChildWithParent :: (n -> n') -> (n' -> n -> n') -> Tree n e l -> Tree n' e l
  )

import bio.db
  ( searchEntrez as fetchIds                    -- fetchIds :: EntrezSearchConfig -> Query -> [Str]
  , nucleotideAccessionToXml as fetchRecords  -- fetchIdRecords :: [Str] -> [Str]
  )

import base
  ( at        -- at :: [a] -> Int -> a
  , id
  , map
  , ne
  , concat
  , filter
  , shard     -- shard :: Int -> [a] -> [[a]]
  , elem      -- elem :: a -> [a] -> Bool
  , fst       -- fst :: (a, b) -> a
  , gt        -- gt :: Int -> Int -> Bool
  , eq        -- eq :: Int -> Int -> Bool
  , head      -- head :: [a] -> a
  , ifelse    -- ifelse :: Bool -> a -> a -> a
  , join      -- join :: [a] -> [a] -> [a]
  , keys      -- keys :: Map a b -> [a]
  , length    -- length :: [a] -> Int
  , lengthS   -- lengthS :: Str -> Int
  , onFst     -- onFst :: (a -> a') -> (a, b) -> (a', b)
  , sleep     -- sleep :: Real -> a -> a
  , snd       -- snd :: (a, b) -> b
  , unique    -- unique :: [a] -> [a]
  , withSnds  -- withVals :: ([a] -> [b]) -> [(c, a)] -> [(c, b)]
  , readMap   -- readMap :: Filename -> Map key val
  )

source Py from "analysis-functions.py"
  ( "parseRecord"
  , "labelRef"
  , "plotTree"
  )

parseRecord :: Str -> (Meta, Sequence)
labelRef :: Map Accession Clade -> Meta -> Meta
plotTree :: Filename -> Tree n Real Meta -> ()


-- analysis :: Date -> Date -> Filename -> Filename -> ()
analysis mindate maxdate reffile treefile
  = ( plotTree treefile
    . classify
    . treeBy treeify
    . withSnds align  -- TODO: rethink this ... this is rather particular
    . search config refmap
    ) query
  where
    query = "Influenza+A+Virus[Organism]+H3N2[ALL]+HA[ALL]"
    config = { email = "weena@mlang.com"
             , db = "nuccore"
             , mindate = mindate
             , maxdate = maxdate
             , retmax = 1000
             }
    refmap = readMap reffile


-- search :: EntrezSearchConfig -> Map Accession Clade -> Query -> [(Meta, Sequence)]
search config refs query =
  ( map (onFst (labelRef refs))
  . concat
  . map ( map parseRecord
        . sleep 1.0
        . fetchRecords
        )
  . shard 100
  . join (keys refs)
  . fetchIds config
  ) query


classify :: Tree () e Meta -> Tree Str e Meta
classify Cpp :: Tree () e Meta -> Tree "std::string" e Meta
classify = push . pullNode pullLeaf pullClade where

  pullLeaf leaf = leaf@clade

  pullClade xs
    = ifelse (eq (length seenClades) 1)
             (head seenClades) ""
    where
      seenClades = ( unique
                   . filter (ne 0 . lengthS)
                   ) xs
  push = mapChildWithParent id (ifelse (eq 0 (lengthS c)))
