# Julia language descriptor for morloc generic translator
# This file is read by the compiler to generate Julia pool code.

# Identity
ldName: julia
ldExtension: jl

# Literals
ldBoolTrue: "true"
ldBoolFalse: "false"
ldNullLiteral: "nothing"

# Constructors
ldListStyle: bracket             # [a, b, c]
ldTupleConstructor: ""           # (a, b, c) -- bare tuples
ldRecordConstructor: "Dict"      # Dict("k" => v, ...)
ldRecordSeparator: "=>"          # Dict("k" => v)

# Access styles
ldIndexStyle: one_bracket        # a[1] (1-indexed)
ldKeyAccess: bracket             # d["key"]
ldFieldAccess: dot               # obj.field

# Serialize/deserialize function names (from juliamorloc.jl)
ldSerializeFn: "MorlocRuntime.put_value"
ldDeserializeFn: "MorlocRuntime.get_value"

# Foreign call
ldForeignCallFn: "MorlocRuntime.foreign_call"
ldForeignCallSocketPath: "joinpath"
ldForeignCallIntSuffix: ""

# Syntax styles
ldAssignment: equals             # x = expr
ldFunctionDef: end_block         # function f(args) ... end
ldLambda: arrow                  # (args) -> body
ldPartialApp: arrow_wrapper      # (bound...) -> f(ctx..., bound...)
ldSuspend: arrow                 # () -> expr
ldMapList: comprehension         # [body for x in col]
ldPattern: dollar_interp         # string("prefix", var, "suffix")
ldDispatchTable: arrow_dict      # Dict(mid => fn, ...)

# Import syntax
ldImportPrefix: "include("
ldIncludeRelToFile: true          # Julia's include() resolves relative to the file, not CWD

# Pool template (loaded from pool.jl at runtime, left empty here)
ldPoolTemplate: ""
ldBreakMarker: "# <<<BREAK>>>"
ldCommentMarker: "#"

# Execution
ldRunCommand:
  - "julia"
ldIsCompiled: false
