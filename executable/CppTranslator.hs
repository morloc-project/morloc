{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE ViewPatterns #-}

{- |
Module      : CppTranslator
Description : Translate 'SerialManifold' trees into C++ pool source code
Copyright   : (c) Zebulun Arendsee, 2016-2026
License     : Apache-2.0
Maintainer  : z@morloc.io

Stateful C++ translator using the two-phase IR architecture: lower the
'SerialManifold' tree into 'IStmt'/'IExpr' via 'LowerConfig', then print
via 'CppPrinter'. Handles C++-specific concerns like compilation flags,
include paths, struct generation, and template instantiation.
-}
module CppTranslator
  ( translate
  , cppLang
  ) where

import Control.Monad.Identity (Identity)
import qualified Control.Monad.State as CMS
import qualified CppPrinter as CP
import qualified Data.Char as DC
import qualified Data.Set as Set
import Data.Text (Text)
import Morloc.CodeGenerator.Grammars.Common
import Morloc.CodeGenerator.Grammars.Macro (expandMacro)
import Morloc.CodeGenerator.Grammars.Translator.Imperative
  ( IType (..)
  , LowerConfig (..)
  , buildProgramM
  , defaultFoldRules
  , expandDeserialize
  , expandSerialize
  , toIType
  )
import Morloc.CodeGenerator.Namespace
import Morloc.CodeGenerator.Serial
  ( serialAstToType
  , shallowType
  )
import Morloc.Data.Doc
import qualified Morloc.Data.GMap as GMap
import qualified Morloc.Data.Map as Map
import qualified Morloc.Data.Text as MT
import qualified Morloc.Language as ML
import qualified Morloc.Monad as MM
import Morloc.Quasi
import qualified Morloc.System as MS
import qualified Morloc.TypeEval as TE

-- HACK: repeating these here is hacky
-- This same data is repeated in cpp/lang.yaml
cppLang :: ML.Lang
cppLang = ML.Lang "cpp" "cpp"

serialType :: MDoc
serialType = "uint8_t*"

data CallSemantics = Copy | Reference | ConstPtr

class HasCppType a where
  cppTypeOf :: a -> CppTranslator MDoc

  cppArgOf :: CallSemantics -> Arg a -> CppTranslator MDoc

setCallSemantics :: CallSemantics -> MDoc -> MDoc
setCallSemantics Copy typestr = typestr
setCallSemantics Reference typestr = "const" <+> typestr <> "&"
setCallSemantics ConstPtr typestr = "const" <+> typestr

chooseCallSemantics :: TypeM -> CallSemantics
chooseCallSemantics Passthrough = ConstPtr -- const uint8_t* packet
chooseCallSemantics (Serial _) = ConstPtr -- const uint8_t* packet
chooseCallSemantics (Native _) = Reference -- for now, primitives should be pass by copy
chooseCallSemantics (Function _ _) = Copy -- currently not used

instance HasCppType TypeM where
  cppTypeOf (Serial _) = return serialType
  cppTypeOf (Native c) = cppTypeOf c
  cppTypeOf Passthrough = return serialType
  cppTypeOf (Function ts t) = do
    t' <- cppTypeOf t
    ts' <- mapM cppTypeOf ts
    return $ "std::function<" <> t' <> tupled ts' <> ">"

  cppArgOf s (Arg i t) = do
    typeStr <- cppTypeOf t
    let typeStrQualified = setCallSemantics s typeStr
    return $ case t of
      (Serial _) -> typeStrQualified <+> svarNamer i
      (Native _) -> typeStrQualified <+> nvarNamer i
      Passthrough -> typeStrQualified <+> svarNamer i
      (Function _ _) -> typeStrQualified <+> nvarNamer i

instance HasCppType NativeManifold where
  cppTypeOf = cppTypeOf . typeMof
  cppArgOf s r = cppArgOf s $ fmap typeMof r

instance {-# OVERLAPPABLE #-} (HasTypeF e) => HasCppType e where
  cppTypeOf = f . typeFof
    where
      f (UnkF (FV _ x)) = return $ pretty x
      f (VarF (FV _ x)) = return $ pretty x
      f (FunF ts t) = do
        t' <- f t
        ts' <- mapM f ts
        return $ "std::function<" <> t' <> tupled ts' <> ">"
      f (AppF t ts) = do
        t' <- f t
        ts' <- mapM f ts
        return . pretty $ expandMacro (render t') (map render ts')
      f t@(NamF _ (FV gc (CV "struct")) _ rs) = do
        recmap <- CMS.gets translatorRecmap
        -- handle autogenerated structs
        case lookup (FV gc (CV "struct"), map fst rs) recmap of
          (Just rec) -> do
            params <- typeParams (zip (map snd (recFields rec)) (map snd rs))
            return $ recName rec <> params
          Nothing -> error $ "Record missing from recmap: " <> show t <> " from map: " <> show recmap
      f (NamF _ (FV _ s) ps _) = do
        ps' <- mapM f ps
        return $ pretty s <> CP.printRecordTemplate ps'
      f (ThunkF t) = do
        t' <- f t
        return $ "std::function<" <> t' <> "()" <> ">"

  cppArgOf s (Arg i t) = do
    t' <- cppTypeOf (typeFof t)
    return $ setCallSemantics s t' <+> nvarNamer i

data CppTranslatorState = CppTranslatorState
  { translatorCounter :: Int
  , translatorRecmap :: RecMap
  , translatorSignatureSet :: Set.Set Int
  , translatorLocalManifoldSet :: Set.Set Int
  , translatorRemoteManifoldSet :: Set.Set Int
  , translatorCurrentManifold :: Int
  }

instance Defaultable CppTranslatorState where
  defaultValue =
    CppTranslatorState
      { translatorCounter = 0
      , translatorRecmap = []
      , translatorSignatureSet = Set.empty
      , translatorLocalManifoldSet = Set.empty
      , translatorRemoteManifoldSet = Set.empty
      , translatorCurrentManifold = -1 -- -1 indicates we are not inside a manifold
      }

type CppTranslator a = CMS.StateT CppTranslatorState Identity a
type CppTranslatorM = CMS.StateT CppTranslatorState Identity

getCounter :: CppTranslator Int
getCounter = do
  s <- CMS.get
  let i = translatorCounter s
  CMS.put $ s {translatorCounter = translatorCounter s + 1}
  return i

resetCounter :: CppTranslator ()
resetCounter = do
  s <- CMS.get
  CMS.put $ s {translatorCounter = 0}

translate :: [Source] -> [SerialManifold] -> MorlocMonad Script
translate srcs es = do
  -- scopeMap :: GMap Int MVar (Map.Map Lang Scope)
  scopeMap <- MM.gets stateConcreteTypedefs

  -- universalScopeMap :: GMap Int MVar Scope
  universalScopeMap <- MM.gets stateUniversalConcreteTypedefs

  let recmap = unifyRecords . concatMap collectRecords $ es
      translatorState = defaultValue {translatorRecmap = recmap}
      code = CMS.evalState (makeCppCode srcs es universalScopeMap scopeMap) translatorState

  maker <- makeTheMaker srcs

  poolSubdir <- MM.getModuleName

  return $
    Script
      { scriptBase = "pool"
      , scriptLang = cppLang
      , scriptCode = "." :/ Dir "pools" [Dir poolSubdir [File "pool.cpp" (Code . render $ code)]]
      , scriptMake = maker
      }

makeCppCode ::
  [Source] ->
  [SerialManifold] ->
  Map.Map Lang Scope ->
  GMap Int MVar (Map.Map Lang Scope) ->
  CppTranslator MDoc
makeCppCode srcs es univeralScopeMap scopeMap = do
  -- ([MDoc], [MDoc])
  (srcDecl, srcSerial) <- generateSourcedSerializers univeralScopeMap scopeMap es

  -- write include statements for sources
  let includeDocs = map translateSource (unique . mapMaybe srcPath $ srcs)

  signatures <- concat <$> mapM makeSignature es

  (autoDecl, autoSerial) <- generateAnonymousStructs
  let serializationCode = autoDecl ++ srcDecl ++ autoSerial ++ srcSerial

  -- build the program (translates each manifold tree)
  program <- buildProgramM includeDocs es translateSegment

  -- create and return complete pool script
  return $ CP.printProgram serializationCode signatures program

metaTypedefs ::
  GMap Int MVar (Map.Map Lang Scope) ->
  Int -> -- manifold index
  Scope
metaTypedefs tmap i =
  case GMap.lookup i tmap of
    (GMapJust langmap) -> case Map.lookup cppLang langmap of
      (Just scope) -> Map.filter (not . null) scope
      Nothing -> Map.empty
    _ -> Map.empty

makeTheMaker :: [Source] -> MorlocMonad [SysCommand]
makeTheMaker srcs = do
  poolSubdir <- MM.getModuleName
  let outfile = pretty $ "pools" </> poolSubdir </> ML.makeExecutablePoolName cppLang
  let src = pretty $ "pools" </> poolSubdir </> ML.makeSourcePoolName cppLang

  (_, flags, includes) <- handleFlagsAndPaths srcs

  let incs = "-I." : [pretty ("-I" <> i) | i <- includes]
  let flags' = map pretty flags

  let cmd =
        SysRun . Code . render $
          [idoc|g++ -O2 -o #{outfile} #{src} #{hsep flags'} #{hsep incs}|]

  return [cmd]

makeSignature :: SerialManifold -> CppTranslator [MDoc]
makeSignature = foldWithSerialManifoldM fm
  where
    fm =
      defaultValue
        { opFoldWithSerialManifoldM = serialManifold
        , opFoldWithNativeManifoldM = nativeManifold
        }

    serialManifold (SerialManifold m _ form _ _) _ = manifoldSignature m serialType form

    nativeManifold e@(NativeManifold m _ form _) _ = do
      typestr <- cppTypeOf e
      manifoldSignature m typestr form

    manifoldSignature ::
      (HasTypeM t) => Int -> MDoc -> ManifoldForm (Or TypeS TypeF) t -> CppTranslator [MDoc]
    manifoldSignature i typestr form = do
      s <- CMS.get
      if Set.member i (translatorSignatureSet s)
        then return []
        else do
          let formArgs = typeMofForm form

          args <- mapM (\r@(Arg _ t) -> cppArgOf (chooseCallSemantics t) r) formArgs
          CMS.put (s {translatorSignatureSet = Set.insert i (translatorSignatureSet s)})
          return [typestr <+> manNamer i <> tupled args <> ";"]

tupleKey :: Int -> MDoc -> MDoc
tupleKey i v = [idoc|std::get<#{pretty i}>(#{v})|]

recordAccess :: MDoc -> MDoc -> MDoc
recordAccess record field = record <> "." <> field

cppLowerConfig :: LowerConfig CppTranslatorM
cppLowerConfig =
  LowerConfig
    { lcSrcName = \src -> pretty (srcName src)
    , lcTypeOf = \t -> Just . toIType <$> cppTypeOf t
    , lcSerialAstType = serializeTypeOf
    , lcDeserialAstType = \s -> Just . toIType <$> cppTypeOf (shallowType s)
    , lcRawDeserialAstType = rawTypeOf
    , lcTemplateArgs = templateArgs
    , lcTypeMOf = \_ -> return Nothing
    , lcPackerName = \src -> pretty (srcName src)
    , lcUnpackerName = \src -> pretty (srcName src)
    , lcRecordAccessor = \_ _ -> recordAccess
    , lcDeserialRecordAccessor = \i _ v -> tupleKey i v
    , lcTupleAccessor = tupleKey
    , lcNewIndex = getCounter
    , lcPrintExpr = CP.printExpr
    , lcPrintStmt = CP.printStmt
    , lcEvalPattern = \t p xs -> do
        state <- CMS.get
        return $ evaluatePattern state t p xs
    , lcListConstructor = \_ _ es -> encloseSep "{" "}" "," es
    , lcTupleConstructor = \_ -> ((<>) "std::make_tuple" . tupled)
    , lcRecordConstructor = \recType _ _ _ rs -> do
        t <- cppTypeOf recType
        idx <- getCounter
        let v' = "a" <> pretty idx
            decl = t <+> v' <+> "=" <+> encloseSep "{" "}" "," (map snd rs) <> ";"
        return $ defaultValue {poolExpr = v', poolPriorLines = [decl]}
    , lcForeignCall = \socketFile mid args ->
        let argList = [dquotes socketFile, pretty mid] <> args <> ["NULL"]
         in [idoc|foreign_call#{tupled argList}|]
    , lcRemoteCall = \socketFile mid res args -> do
        let resMem = pretty $ remoteResourcesMemory res
            resTime = pretty $ remoteResourcesTime res
            resCPU = pretty $ remoteResourcesThreads res
            resGPU = pretty $ remoteResourcesGpus res
            cacheDir = ".morloc-cache"
            argList = encloseSep "{" "}" "," args
            setup =
              [idoc|resources_t resources = {#{resMem}, #{resTime}, #{resCPU}, #{resGPU}};
const uint8_t* args[] = #{argList};
char* errmsg = NULL;|]
            call =
              [idoc|remote_call(
    #{pretty mid},
    #{dquotes socketFile},
    #{dquotes cacheDir},
    &resources,
    args,
    #{pretty (length args)},
    &errmsg
);
PROPAGATE_ERROR(errmsg)|]
        return $ defaultValue {poolExpr = call, poolPriorLines = [setup]}
    , lcMakeLet = \namer letIndex mt e1 e2 -> do
        typestr <- case mt of
          (Just t) -> cppTypeOf t
          Nothing -> return serialType
        return $ makeLet namer letIndex typestr e1 e2
    , lcReturn = \e -> "return(" <> e <> ");"
    , lcMakeSuspend = \stmts expr -> (,) [] $ case stmts of
        [] -> "[&](){return " <> expr <> ";}"
        _ -> "[&](){" <> nest 4 (line <> vsep (stmts <> ["return " <> expr <> ";"])) <> line <> "}"
    , lcSerialize = \v s -> serialize v s
    , lcDeserialize = \t v s -> do
        typestr <- cppTypeOf t
        deserialize v typestr s
    , lcMakeFunction = \mname args manifoldType priorLines body headForm -> do
        callIndex <- CMS.gets translatorCurrentManifold
        state <- CMS.get
        let alreadyDone = case headForm of
              (Just HeadManifoldFormRemoteWorker) -> Set.member callIndex (translatorRemoteManifoldSet state)
              _ -> Set.member callIndex (translatorLocalManifoldSet state)
        if alreadyDone
          then return Nothing
          else do
            case headForm of
              (Just HeadManifoldFormRemoteWorker) ->
                CMS.modify
                  (\s -> s {translatorRemoteManifoldSet = Set.insert callIndex (translatorRemoteManifoldSet s)})
              _ ->
                CMS.modify
                  (\s -> s {translatorLocalManifoldSet = Set.insert callIndex (translatorLocalManifoldSet s)})
            returnTypeStr <- returnType manifoldType
            typedArgs <- mapM (\r@(Arg _ t) -> cppArgOf (chooseCallSemantics t) r) args
            let fullName = mname <> mnameExt headForm
                decl = returnTypeStr <+> fullName <> tupled typedArgs
                tryBody = block 4 "try" (vsep $ priorLines <> [body])
                throwStatement =
                  vsep
                    [ [idoc|std::string error_message = "Error raised in C++ pool by #{mname}:\n" + std::string(e.what());|]
                    , [idoc|throw std::runtime_error(error_message);|]
                    ]
                catchBody = block 4 "catch (const std::exception& e)" throwStatement
                tryCatchBody = tryBody <+> catchBody
            return . Just . block 4 decl . vsep $ [tryCatchBody]
    , lcMakeLambda = \mname contextArgs boundArgs ->
        let vs' = take (length boundArgs) (map (\j -> "std::placeholders::_" <> viaShow j) ([1 ..] :: [Int]))
         in [idoc|std::bind(#{cat (punctuate "," (mname : (contextArgs ++ vs')))})|]
    }
  where
    -- For serialization, records become tuples (that's what _put_value/toAnything expects)
    serializeTypeOf :: SerialAST -> CppTranslator (Maybe IType)
    serializeTypeOf (SerialObject _ _ _ rs) = Just . toIType <$> recordToCppTuple (map snd rs)
    serializeTypeOf s = Just . toIType <$> cppTypeOf (serialAstToType s)

    rawTypeOf :: SerialAST -> CppTranslator (Maybe IType)
    rawTypeOf (SerialObject _ _ _ rs) = Just . toIType <$> recordToCppTuple (map snd rs)
    rawTypeOf s = Just . toIType <$> cppTypeOf (serialAstToType s)

    templateArgs :: [(Text, TypeF)] -> CppTranslator (Maybe [IType])
    templateArgs [] = return Nothing
    templateArgs qs = Just . map toIType <$> mapM (cppTypeOf . snd) qs

    makeLet :: (Int -> MDoc) -> Int -> MDoc -> PoolDocs -> PoolDocs -> PoolDocs
    makeLet namer letIndex typestr (PoolDocs ms1 e1 rs1 pes1) (PoolDocs ms2 e2 rs2 pes2) =
      let letAssignment = [idoc|#{typestr} #{namer letIndex} = #{e1};|]
          rs = rs1 <> [letAssignment] <> rs2
       in PoolDocs
            { poolCompleteManifolds = ms1 <> ms2
            , poolExpr = e2
            , poolPriorLines = rs
            , poolPriorExprs = pes1 <> pes2
            }

    mnameExt :: Maybe HeadManifoldForm -> MDoc
    mnameExt (Just HeadManifoldFormRemoteWorker) = "_remote"
    mnameExt _ = ""

    returnType :: TypeM -> CppTranslator MDoc
    returnType (Function _ t) = cppTypeOf t
    returnType t = cppTypeOf t

-- Use `#include "foo.h"` rather than `#include <foo.h>`
translateSource ::
  -- | Path to a header (e.g., `$MORLOC_HOME/src/foo.h`)
  Path ->
  MDoc
translateSource path = "#include" <+> (dquotes . pretty) path

serialize :: MDoc -> SerialAST -> CppTranslator PoolDocs
serialize v s = do
  (expr, stmts) <- expandSerialize cppLowerConfig v s
  return $
    PoolDocs
      { poolCompleteManifolds = []
      , poolExpr = CP.printExpr expr
      , poolPriorLines = map CP.printStmt stmts
      , poolPriorExprs = []
      }

-- reverse of serialize, parameters are the same
deserialize :: MDoc -> MDoc -> SerialAST -> CppTranslator (MDoc, [MDoc])
deserialize varname0 typestr0 s0 = do
  (expr, stmts) <- expandDeserialize cppLowerConfig varname0 s0
  let rendered = CP.printExpr expr
  if null stmts
    then return (rendered, [])
    else do
      schemaVar <- helperNamer <$> getCounter
      let final = [idoc|#{typestr0} #{schemaVar} = #{rendered};|]
      return (schemaVar, map CP.printStmt stmts ++ [final])

recordToCppTuple :: [SerialAST] -> CppTranslator MDoc
recordToCppTuple ts = do
  tsDocs <- mapM (cppTypeOf . serialAstToType) ts
  return $ "std::tuple" <> encloseSep "<" ">" "," tsDocs

translateSegment :: SerialManifold -> CppTranslator MDoc
translateSegment m0 = do
  resetCounter
  e <- surroundFoldSerialManifoldM manifoldIndexer (defaultFoldRules cppLowerConfig) m0
  return $ renderPoolDocs e
  where
    manifoldIndexer =
      makeManifoldIndexer
        (CMS.gets translatorCurrentManifold)
        (\i -> CMS.modify (\s -> s {translatorCurrentManifold = i}))

-- handle string interpolation
evaluatePattern :: CppTranslatorState -> TypeF -> Pattern -> [MDoc] -> MDoc
evaluatePattern _ _ (PatternText s ss) xs = "interweave_strings" <> tupled [fragments, insertions]
  where
    fragments = encloseSep "{" "}" ", " (map (dquotes . pretty) (s : ss))
    insertions = encloseSep "{" "}" ", " xs

-- handle getters
evaluatePattern _ _ (PatternStruct (ungroup -> [ss])) [m] =
  writeSelector m ss
evaluatePattern _ _ (PatternStruct (ungroup -> sss)) [m] =
  encloseSep "{" "}" "," (map (writeSelector m) sss)
evaluatePattern state0 t0 (PatternStruct s0) (m0 : xs0) =
  patternSetter makeTuple makeRecord accessTuple accessRecord m0 t0 s0 xs0
  where
    makeTuple (AppF _ ts) xs =
      let tupleTypes = CMS.evalState (mapM cppTypeOf ts) state0
       in "std::tuple" <> encloseSep "<" ">" "," tupleTypes <> tupled xs
    makeTuple _ _ = error "Unreachable"

    makeRecord _ xs = encloseSep "{" "}" ", " xs

    accessTuple _ m i = "std::get<" <> pretty i <> ">(" <> m <> ")"
    accessRecord _ d k = d <> "." <> pretty k
evaluatePattern _ _ (PatternStruct _) [] = error "Unreachable illegal pattern"

writeSelector :: MDoc -> [Either Int Text] -> MDoc
writeSelector d [] = d
writeSelector d (Right k : rs) = writeSelector (d <> "." <> pretty k) rs
writeSelector d (Left i : rs) = writeSelector ("std::get<" <> pretty i <> ">" <> parens d) rs

typeParams :: [(Maybe TypeF, TypeF)] -> CppTranslator MDoc
typeParams ts = CP.printRecordTemplate <$> mapM cppTypeOf [t | (Nothing, t) <- ts]

generateAnonymousStructs :: CppTranslator ([MDoc], [MDoc])
generateAnonymousStructs = do
  recmap <- CMS.gets translatorRecmap

  xs <- mapM makeSerializers (reverse . map snd $ recmap)

  return (concatMap fst xs, concatMap snd xs)
  where
    makeSerializers :: RecEntry -> CppTranslator ([MDoc], [MDoc])
    makeSerializers rec = do
      let templateTerms = map (("T" <>) . pretty) ([1 ..] :: [Int])
          rs' = zip templateTerms (recFields rec)

      let params = [t | (t, (_, Nothing)) <- rs']
          rname = recName rec
          rtype = rname <> CP.printRecordTemplate [v | (v, (_, Nothing)) <- rs']

      let fieldNames = [k | (_, (k, _)) <- rs']

      fieldTypes <- mapM (\(t, v) -> maybeM t cppTypeOf v) [(t', v') | (t', (_, v')) <- rs']

      let fields = [(pretty k, v) | (k, v) <- zip fieldNames fieldTypes]

      let structDecl = CP.printStructTypedef params rname fields
          serializer = CP.printSerializer params rtype fields
          deserializer = CP.printDeserializer False params rtype fields

      return ([structDecl], [serializer, deserializer])

    -- monadic form of `maybe` function
    maybeM :: (Monad m) => a -> (b -> m a) -> Maybe b -> m a
    maybeM _ f (Just x) = f x
    maybeM x _ Nothing = return x

generateSourcedSerializers ::
  Map.Map Lang Scope ->
  GMap Int MVar (Map.Map Lang Scope) ->
  [SerialManifold] -> -- all segments that can be called in this pool
  CppTranslator
    ( [MDoc]
    , [MDoc]
    )
generateSourcedSerializers univeralScopeMap scopeMap es0 = do
  -- find the scopes that are used in this manifold
  -- we need to generate (de)serializers for all records
  typedef <- Map.unions <$> mapM (foldSerialManifoldM fm) es0

  scope <- case Map.lookup cppLang univeralScopeMap of
    (Just scope) -> return scope
    Nothing -> return Map.empty

  foldl groupQuad ([], []) . concat . Map.elems <$> Map.mapWithKeyM (makeSerials scope) typedef
  where
    -- given the universal map of scopes, pull out every one that is used in this subtree
    fm =
      defaultValue
        { opSerialManifoldM = \(SerialManifold_ i _ _ _ e) -> return $ Map.unionWith mergeScopes (metaTypedefs scopeMap i) e
        , opNativeManifoldM = \(NativeManifold_ i _ _ e) -> return $ Map.unionWith mergeScopes (metaTypedefs scopeMap i) e
        }

    -- there are likely to be repeats in the scopes, we only want the unique ones
    mergeScopes xs ys = unique (xs <> ys)

    groupQuad :: ([a], [a]) -> (a, a) -> ([a], [a])
    groupQuad (xs, ys) (x, y) = (x : xs, y : ys)

    makeSerials ::
      Scope -> TVar -> [([Either TVar TypeU], TypeU, ArgDoc, Bool)] -> CppTranslator [(MDoc, MDoc)]
    makeSerials s v xs = catMaybes <$> mapM (makeSerial s v) xs

    makeSerial ::
      Scope -> TVar -> ([Either TVar TypeU], TypeU, ArgDoc, Bool) -> CppTranslator (Maybe (MDoc, MDoc))
    makeSerial _ _ (_, NamU _ (TV "struct") _ _, _, _) = return Nothing
    makeSerial scope _ (ps, NamU r (TV v) _ rs, _, _) = do
      params <- mapM (either (\p -> return $ "T" <> pretty p) (\_ -> return "XXX_FIXME")) ps
      let templateTerms = ["T" <> pretty p | Left p <- ps]
          rtype = pretty v <> CP.printRecordTemplate templateTerms
          rs' = map (second (evaluateTypeU scope)) rs
          fields = [(pretty k, showDefType ps (typeOf t)) | (k, t) <- rs']
          serializer = CP.printSerializer params rtype fields
          deserializer = CP.printDeserializer (r == NamObject) params rtype fields
      return $ Just (serializer, deserializer)
    makeSerial _ _ _ = return Nothing

    evaluateTypeU :: Scope -> TypeU -> TypeU
    evaluateTypeU scope t = case TE.evaluateType scope t of
      (Left e) -> error $ show e
      (Right t') -> t'

    showDefType :: [Either TVar TypeU] -> Type -> MDoc
    showDefType ps (UnkT v)
      | (Left v) `elem` ps = "T" <> pretty v
      | otherwise = pretty v
    showDefType ps (VarT v)
      | (Left v) `elem` ps = "T" <> pretty v
      | otherwise = pretty v
    showDefType _ (FunT _ _) = error "Cannot serialize functions"
    showDefType _ (NamT _ v _ _) = pretty v
    showDefType ps (AppT (VarT (TV v)) ts) = pretty $ expandMacro v (map (render . showDefType ps) ts)
    showDefType _ (AppT _ _) = error "AppT is only OK with VarT, for now"
    showDefType _ (ThunkT _) = error "Cannot show ThunkT"

-- C++ specific source handling (flags, headers, libraries)

handleFlagsAndPaths :: [Source] -> MorlocMonad ([Source], [Text], [Path])
handleFlagsAndPaths srcs = do
  state <- MM.get
  let gccversion = gccVersionFlag . foldl max 0 . map packageCppVersion $ statePackageMeta state
  let explicitLibs = map ("-l" <>) . unique . concatMap packageDependencies $ statePackageMeta state
  (srcs', libflags, paths) <-
    fmap unzip3
      . mapM flagAndPath
      . unique
      $ [s | s <- srcs, srcLang s == cppLang]

  home <- MM.asks configHome
  let mlcInclude = ["-I" <> home <> "/include"]
      mlcPch = ["-include", "morloc_pch.hpp"]
      mlcLib = ["-L" <> home <> "/lib", "-Wl,-rpath," <> home <> "/lib", "-lmorloc", "-lcppmorloc", "-lpthread"]

  return
    ( filter (isJust . srcPath) srcs'
    , [gccversion] <> explicitLibs ++ (map MT.pack . concat) (mlcPch : mlcInclude : mlcLib : libflags)
    , unique (catMaybes paths)
    )

gccVersionFlag :: Int -> Text
gccVersionFlag i
  | i <= 17 = "-std=c++17"
  | otherwise = "-std=c++" <> MT.show' i

flagAndPath :: Source -> MorlocMonad (Source, [String], Maybe Path)
flagAndPath src@(Source _ srcL (Just p) _ _ _ _) | srcL == cppLang =
  case (MS.takeDirectory p, MS.dropExtensions (MS.takeFileName p), MS.takeExtensions p) of
    (".", base, "") -> do
      header <- lookupHeader base
      libFlags <- lookupLib base
      return (src {srcPath = Just header}, libFlags, Just (MS.takeDirectory header))
    (dir, base, _) -> do
      libFlags <- lookupLib base
      return (src, libFlags, Just dir)
  where
    lookupHeader :: String -> MorlocMonad Path
    lookupHeader base = do
      home <- MM.asks configHome
      let allPaths = getHeaderPaths home base [".h", ".hpp", ".hxx"]
      existingPaths <- liftIO . fmap catMaybes . mapM getFile $ allPaths
      case existingPaths of
        (x : _) -> return x
        [] -> MM.throwSystemError $ "Header file " <> pretty base <> ".* not found"

    lookupLib :: String -> MorlocMonad [String]
    lookupLib base = do
      home <- MM.asks configHome
      let libnamebase = filter DC.isAlphaNum (map DC.toLower base)
      let libname = "lib" <> libnamebase <> ".so"
      let allPaths = getLibraryPaths home base libname
      existingPaths <- liftIO . fmap catMaybes . mapM getFile $ allPaths
      case existingPaths of
        (libpath : _) -> do
          libdir <- liftIO . MS.canonicalizePath . MS.takeDirectory $ libpath
          return
            [ "-Wl,-rpath=" <> libdir
            , "-L" <> libdir
            , "-l" <> libnamebase
            ]
        [] -> return []
flagAndPath src@(Source _ srcL Nothing _ _ _ _) | srcL == cppLang = return (src, [], Nothing)
flagAndPath _ = MM.throwSystemError $ "flagAndPath should only be called for C++ functions"

getFile :: Path -> IO (Maybe Path)
getFile x = do
  exists <- MS.doesFileExist x
  return $
    if exists
      then Just x
      else Nothing

getHeaderPaths :: Path -> String -> [String] -> [Path]
getHeaderPaths lib base exts = [path <> ext | path <- paths, ext <- exts]
  where
    paths =
      map
        MS.joinPath
        [ [base]
        , ["include", base]
        , [base, base]
        , [lib, "include", base]
        , [lib, "src", base, base]
        , ["/usr/include", base]
        , ["/usr/local/include", base]
        ]

getLibraryPaths :: Path -> String -> String -> [Path]
getLibraryPaths lib base sofile =
  map
    MS.joinPath
    [ [sofile]
    , ["lib", sofile]
    , [base, sofile]
    , [lib, "lib", sofile]
    , [lib, "src", base, sofile]
    , [lib, "src", base, "lib", sofile]
    ]
