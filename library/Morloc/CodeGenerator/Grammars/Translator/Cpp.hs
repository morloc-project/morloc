{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE ViewPatterns #-}

{- |
Module      : Morloc.CodeGenerator.Grammars.Translator.Cpp
Description : C++ translator
Copyright   : (c) Zebulun Arendsee, 2016-2026
License     : Apache-2.0
Maintainer  : z@morloc.io
-}
module Morloc.CodeGenerator.Grammars.Translator.Cpp
  ( translate
  , preprocess
  ) where

import Control.Monad.Identity (Identity)
import qualified Control.Monad.State as CMS
import qualified Data.Set as Set
import Data.Text (Text)
import Morloc.CodeGenerator.Grammars.Common
import Morloc.CodeGenerator.Grammars.Macro (expandMacro)
import Morloc.CodeGenerator.Grammars.Translator.Imperative (LowerConfig(..), IType(..), expandSerialize, expandDeserialize, lowerSerialExpr, lowerNativeExpr)
import qualified Morloc.CodeGenerator.Grammars.Translator.Printer.Cpp as CP
import Morloc.CodeGenerator.Grammars.Translator.Syntax (genericMakeSerialArg, genericMakeNativeArg)
import Morloc.CodeGenerator.Namespace
import Morloc.CodeGenerator.Serial
  ( serialAstToType
  , shallowType
  )
import Morloc.Data.Doc
import qualified Morloc.Data.GMap as GMap
import qualified Morloc.Data.Map as Map
import Morloc.DataFiles as DF
import qualified Morloc.Language as ML
import qualified Morloc.Module as Mod
import qualified Morloc.Monad as MM
import Morloc.Quasi
import qualified Morloc.TypeEval as TE

data CallSemantics = Copy | Reference | ConstPtr

class HasCppType a where
  cppTypeOf :: a -> CppTranslator MDoc

  cppArgOf :: CallSemantics -> Arg a -> CppTranslator MDoc

setCallSemantics :: CallSemantics -> MDoc -> MDoc
setCallSemantics Copy typestr = typestr
setCallSemantics Reference typestr = "const" <+> typestr <> "&"
setCallSemantics ConstPtr typestr = "const" <+> typestr

chooseCallSemantics :: TypeM -> CallSemantics
chooseCallSemantics Passthrough = ConstPtr -- const uint8_t* packet
chooseCallSemantics (Serial _) = ConstPtr -- const uint8_t* packet
chooseCallSemantics (Native _) = Reference -- for now, primitives should be pass by copy
chooseCallSemantics (Function _ _) = Copy -- currently not used

instance HasCppType TypeM where
  cppTypeOf (Serial _) = return serialType
  cppTypeOf (Native c) = cppTypeOf c
  cppTypeOf Passthrough = return serialType
  cppTypeOf (Function ts t) = do
    t' <- cppTypeOf t
    ts' <- mapM cppTypeOf ts
    return $ "std::function<" <> t' <> tupled ts' <> ">"

  cppArgOf s (Arg i t) = do
    typeStr <- cppTypeOf t
    let typeStrQualified = setCallSemantics s typeStr
    return $ case t of
      (Serial _) -> typeStrQualified <+> svarNamer i
      (Native _) -> typeStrQualified <+> nvarNamer i
      Passthrough -> typeStrQualified <+> svarNamer i
      (Function _ _) -> typeStrQualified <+> nvarNamer i

instance HasCppType NativeManifold where
  cppTypeOf = cppTypeOf . typeMof
  cppArgOf s r = cppArgOf s $ fmap typeMof r

instance {-# OVERLAPPABLE #-} (HasTypeF e) => HasCppType e where
  cppTypeOf = f . typeFof
    where
      f (UnkF (FV _ x)) = return $ pretty x
      f (VarF (FV _ x)) = return $ pretty x
      f (FunF ts t) = do
        t' <- f t
        ts' <- mapM f ts
        return $ "std::function<" <> t' <> tupled ts' <> ">"
      f (AppF t ts) = do
        t' <- f t
        ts' <- mapM f ts
        return . pretty $ expandMacro (render t') (map render ts')
      f t@(NamF _ (FV gc (CV "struct")) _ rs) = do
        recmap <- CMS.gets translatorRecmap
        -- handle autogenerated structs
        case lookup (FV gc (CV "struct"), map fst rs) recmap of
          (Just rec) -> do
            params <- typeParams (zip (map snd (recFields rec)) (map snd rs))
            return $ recName rec <> params
          Nothing -> error $ "Record missing from recmap: " <> show t <> " from map: " <> show recmap
      f (NamF _ (FV _ s) ps _) = do
        ps' <- mapM f ps
        return $ pretty s <> recordTemplate ps'

  cppArgOf s (Arg i t) = do
    t' <- cppTypeOf (typeFof t)
    return $ setCallSemantics s t' <+> nvarNamer i

{- | @RecEntry@ stores the common name, keys, and types of records that are not
imported from C++ source. These records are generated as structs in the C++
pool. @unifyRecords@ takes all such records and "unifies" ones with the same
name and keys. The unified records may have different types, but they will
all be instances of the same generic struct. That is, any fields that differ
between instances will be made generic.
-}
data RecEntry = RecEntry
  { recName :: MDoc
  -- ^ the automatically generated name for this anonymous type
  , recFields ::
      [ ( Key -- The field key
        , Maybe TypeF -- The field type if not generic
        )
      ]
  }
  deriving (Show)

-- | @RecMap@ is used to lookup up the struct name shared by all records that are not imported from C++ source.
type RecMap = [((FVar, [Key]), RecEntry)]

data CppTranslatorState = CppTranslatorState
  { translatorCounter :: Int
  , translatorRecmap :: RecMap
  , translatorSignatureSet :: Set.Set Int
  , translatorLocalManifoldSet :: Set.Set Int
  , translatorRemoteManifoldSet :: Set.Set Int
  , translatorCurrentManifold :: Int
  }

instance Defaultable CppTranslatorState where
  defaultValue =
    CppTranslatorState
      { translatorCounter = 0
      , translatorRecmap = []
      , translatorSignatureSet = Set.empty
      , translatorLocalManifoldSet = Set.empty
      , translatorRemoteManifoldSet = Set.empty
      , translatorCurrentManifold = -1 -- -1 indicates we are not inside a manifold
      }

type CppTranslator a = CMS.StateT CppTranslatorState Identity a
type CppTranslatorM = CMS.StateT CppTranslatorState Identity

getCounter :: CppTranslator Int
getCounter = do
  s <- CMS.get
  let i = translatorCounter s
  CMS.put $ s {translatorCounter = translatorCounter s + 1}
  return i

resetCounter :: CppTranslator ()
resetCounter = do
  s <- CMS.get
  CMS.put $ s {translatorCounter = 0}

-- tree rewrites
preprocess :: SerialManifold -> MorlocMonad SerialManifold
preprocess = return . invertSerialManifold

translate :: [Source] -> [SerialManifold] -> MorlocMonad Script
translate srcs es = do
  -- scopeMap :: GMap Int MVar (Map.Map Lang Scope)
  scopeMap <- MM.gets stateConcreteTypedefs

  -- universalScopeMap :: GMap Int MVar Scope
  universalScopeMap <- MM.gets stateUniversalConcreteTypedefs

  let recmap = unifyRecords . concatMap collectRecords $ es
      translatorState = defaultValue {translatorRecmap = recmap}
      code = CMS.evalState (makeCppCode srcs es universalScopeMap scopeMap) translatorState

  maker <- makeTheMaker srcs

  return $
    Script
      { scriptBase = "pool"
      , scriptLang = CppLang
      , scriptCode = "." :/ File "pool.cpp" (Code . render $ code)
      , scriptMake = maker
      }

makeCppCode ::
  [Source] ->
  [SerialManifold] ->
  Map.Map Lang Scope ->
  GMap Int MVar (Map.Map Lang Scope) ->
  CppTranslator MDoc
makeCppCode srcs es univeralScopeMap scopeMap = do
  -- ([MDoc], [MDoc])
  (srcDecl, srcSerial) <- generateSourcedSerializers univeralScopeMap scopeMap es

  -- write include statements for sources
  let includeDocs = map translateSource (unique . mapMaybe srcPath $ srcs)

  let dispatch = makeDispatch es

  signatures <- concat <$> mapM makeSignature es

  (autoDecl, autoSerial) <- generateAnonymousStructs
  let serializationCode = autoDecl ++ srcDecl ++ autoSerial ++ srcSerial

  -- translate each manifold tree, rooted on a call from nexus or another pool
  mDocs <- mapM translateSegment es

  -- create and return complete pool script
  return $ makeMain includeDocs signatures serializationCode mDocs dispatch

metaTypedefs ::
  GMap Int MVar (Map.Map Lang Scope) ->
  Int -> -- manifold index
  Scope
metaTypedefs tmap i =
  case GMap.lookup i tmap of
    (GMapJust langmap) -> case Map.lookup CppLang langmap of
      (Just scope) -> Map.filter (not . null) scope
      Nothing -> Map.empty
    _ -> Map.empty

makeTheMaker :: [Source] -> MorlocMonad [SysCommand]
makeTheMaker srcs = do
  let outfile = pretty $ ML.makeExecutablePoolName CppLang
  let src = pretty (ML.makeSourcePoolName CppLang)

  -- this function cleans up source names (if needed) and generates compiler flags and paths to search
  (_, flags, includes) <- Mod.handleFlagsAndPaths CppLang srcs

  let incs = [pretty ("-I" <> i) | i <- includes]
  let flags' = map pretty flags

  -- TODO: This is garbage - the C++ version should NOT be specified here
  let cmd =
        SysRun . Code . render $
          [idoc|g++ -O3 --std=c++17 -o #{outfile} #{src} #{hsep flags'} #{hsep incs}|]

  return [cmd]

serialType :: MDoc
serialType = pretty $ ML.serialType CppLang

makeSignature :: SerialManifold -> CppTranslator [MDoc]
makeSignature = foldWithSerialManifoldM fm
  where
    fm =
      defaultValue
        { opFoldWithSerialManifoldM = serialManifold
        , opFoldWithNativeManifoldM = nativeManifold
        }

    serialManifold (SerialManifold m _ form _ _) _ = manifoldSignature m serialType form

    nativeManifold e@(NativeManifold m _ form _) _ = do
      typestr <- cppTypeOf e
      manifoldSignature m typestr form

    manifoldSignature ::
      (HasTypeM t) => Int -> MDoc -> ManifoldForm (Or TypeS TypeF) t -> CppTranslator [MDoc]
    manifoldSignature i typestr form = do
      s <- CMS.get
      if Set.member i (translatorSignatureSet s)
        then return []
        else do
          let formArgs = typeMofForm form

          args <- mapM (\r@(Arg _ t) -> cppArgOf (chooseCallSemantics t) r) formArgs
          CMS.put (s {translatorSignatureSet = Set.insert i (translatorSignatureSet s)})
          return [typestr <+> manNamer i <> tupled args <> ";"]

tupleKey :: Int -> MDoc -> MDoc
tupleKey i v = [idoc|std::get<#{pretty i}>(#{v})|]

recordAccess :: MDoc -> MDoc -> MDoc
recordAccess record field = record <> "." <> field

cppLowerConfig :: LowerConfig CppTranslatorM
cppLowerConfig = LowerConfig
  { lcSrcName = \src -> pretty (srcName src)
  , lcTypeOf = \t -> Just . IType <$> cppTypeOf t
  , lcSerialAstType = serializeTypeOf
  , lcDeserialAstType = \s -> Just . IType <$> cppTypeOf (shallowType s)
  , lcRawDeserialAstType = rawTypeOf
  , lcTemplateArgs = templateArgs
  , lcTypeMOf = \_ -> return Nothing
  , lcPackerName = \src -> pretty (srcName src)
  , lcUnpackerName = \src -> pretty (srcName src)
  , lcRecordAccessor = \_ _ -> recordAccess
  , lcDeserialRecordAccessor = \i _ v -> tupleKey i v
  , lcTupleAccessor = tupleKey
  , lcNewIndex = getCounter
  , lcPrintExpr = CP.printExpr
  , lcPrintStmt = CP.printStmt
  , lcEvalPattern = \t p xs -> do
      state <- CMS.get
      return $ evaluatePattern state t p xs
  , lcListConstructor = \_ _ es -> encloseSep "{" "}" "," es
  , lcTupleConstructor = \_ -> ((<>) "std::make_tuple" . tupled)
  , lcRecordConstructor = \recType _ _ _ rs -> do
      t <- cppTypeOf recType
      idx <- getCounter
      let v' = "a" <> pretty idx
          decl = t <+> v' <+> "=" <+> encloseSep "{" "}" "," (map snd rs) <> ";"
      return $ defaultValue {poolExpr = v', poolPriorLines = [decl]}
  , lcForeignCall = \socketFile mid args ->
      let argList = [dquotes socketFile, pretty mid] <> args <> ["NULL"]
       in [idoc|foreign_call#{tupled argList}|]
  , lcRemoteCall = \socketFile mid res args -> do
      let resMem = pretty $ remoteResourcesMemory res
          resTime = pretty $ remoteResourcesTime res
          resCPU = pretty $ remoteResourcesThreads res
          resGPU = pretty $ remoteResourcesGpus res
          cacheDir = ".morloc-cache"
          argList = encloseSep "{" "}" "," args
          setup =
            [idoc|resources_t resources = {#{resMem}, #{resTime}, #{resCPU}, #{resGPU}};
const uint8_t* args[] = #{argList};
char* errmsg = NULL;|]
          call =
            [idoc|remote_call(
    #{pretty mid},
    #{dquotes socketFile},
    #{dquotes cacheDir},
    &resources,
    args,
    #{pretty (length args)},
    &errmsg
);
PROPAGATE_ERROR(errmsg)|]
      return $ defaultValue {poolExpr = call, poolPriorLines = [setup]}
  , lcMakeLet = \namer letIndex mt e1 e2 -> do
      typestr <- case mt of
        (Just t) -> cppTypeOf t
        Nothing -> return serialType
      return $ makeLet namer letIndex typestr e1 e2
  , lcReturn = \e -> "return(" <> e <> ");"
  , lcSerialize = \v s -> serialize v s
  , lcDeserialize = \t v s -> do
      typestr <- cppTypeOf t
      deserialize v typestr s
  }
  where
    -- For serialization, records become tuples (that's what _put_value/toAnything expects)
    serializeTypeOf :: SerialAST -> CppTranslator (Maybe IType)
    serializeTypeOf (SerialObject _ _ _ rs) = Just . IType <$> recordToCppTuple (map snd rs)
    serializeTypeOf s = Just . IType <$> cppTypeOf (serialAstToType s)

    rawTypeOf :: SerialAST -> CppTranslator (Maybe IType)
    rawTypeOf (SerialObject _ _ _ rs) = Just . IType <$> recordToCppTuple (map snd rs)
    rawTypeOf s = Just . IType <$> cppTypeOf (serialAstToType s)

    templateArgs :: [(Text, TypeF)] -> CppTranslator (Maybe [IType])
    templateArgs [] = return Nothing
    templateArgs qs = Just . map IType <$> mapM (cppTypeOf . snd) qs

    makeLet :: (Int -> MDoc) -> Int -> MDoc -> PoolDocs -> PoolDocs -> PoolDocs
    makeLet namer letIndex typestr (PoolDocs ms1 e1 rs1 pes1) (PoolDocs ms2 e2 rs2 pes2) =
      let letAssignment = [idoc|#{typestr} #{namer letIndex} = #{e1};|]
          rs = rs1 <> [letAssignment] <> rs2 <> [e2]
       in PoolDocs
            { poolCompleteManifolds = ms1 <> ms2
            , poolExpr = vsep rs
            , poolPriorLines = []
            , poolPriorExprs = pes1 <> pes2
            }

-- TLDR: Use `#include "foo.h"` rather than `#include <foo.h>`
-- Include statements in C can be either wrapped in angle brackets (e.g.,
-- `<stdio.h>`) or in quotes (e.g., `"myfile.h"`). The difference between these
-- is implementation specific. I currently use the GCC compiler. For quoted
-- strings, it first searches relative to the working directory and then, if
-- nothing is found, searches system files. For angle brackets, it searches
-- only system files: <https://gcc.gnu.org/onlinedocs/cpp/Search-Path.html>. So
-- quoting seems more reasonable, for now. This might change only if I start
-- loading the morloc libraries into the system directories (which might be
-- reasonable), though still, quotes would work.
--
-- UPDATE: The build system will now read the source paths from the Script
-- object and write an `-I${MORLOC_HOME}/lib/${MORLOC_PACKAGE}` argument for
-- g++. This will tell g++ where to look for headers. So now in the generated
-- source code I can just write the basename. This makes the generated code
-- neater (no hard-coded local paths), but now the g++ compiler will search
-- through all the module paths for each file, which introduces the possibility
-- of name conflicts.
--
-- UPDATE: And now those naming conflicts have bitten me. Simply including every
-- module directory is a wretched idea.
translateSource ::
  -- | Path to a header (e.g., `$MORLOC_HOME/src/foo.h`)
  Path ->
  MDoc
translateSource path = "#include" <+> (dquotes . pretty) path

serialize :: MDoc -> SerialAST -> CppTranslator PoolDocs
serialize v s = do
  (expr, stmts) <- expandSerialize cppLowerConfig v s
  return $
    PoolDocs
      { poolCompleteManifolds = []
      , poolExpr = CP.printExpr expr
      , poolPriorLines = map CP.printStmt stmts
      , poolPriorExprs = []
      }

-- reverse of serialize, parameters are the same
deserialize :: MDoc -> MDoc -> SerialAST -> CppTranslator (MDoc, [MDoc])
deserialize varname0 typestr0 s0 = do
  (expr, stmts) <- expandDeserialize cppLowerConfig varname0 s0
  let rendered = CP.printExpr expr
  if null stmts
    then return (rendered, [])
    else do
      schemaVar <- helperNamer <$> getCounter
      let final = [idoc|#{typestr0} #{schemaVar} = #{rendered};|]
      return (schemaVar, map CP.printStmt stmts ++ [final])

recordToCppTuple :: [SerialAST] -> CppTranslator MDoc
recordToCppTuple ts = do
  tsDocs <- mapM (cppTypeOf . serialAstToType) ts
  return $ "std::tuple" <> encloseSep "<" ">" "," tsDocs

translateSegment :: SerialManifold -> CppTranslator MDoc
translateSegment m0 = do
  resetCounter
  e <- surroundFoldSerialManifoldM manifoldIndexer foldRules m0
  return $ vsep . punctuate line $ poolPriorExprs e <> poolCompleteManifolds e
  where
    foldRules =
      FoldWithManifoldM
        { opFoldWithSerialManifoldM = makeSerialManifold
        , opFoldWithNativeManifoldM = makeNativeManifold
        , opFoldWithSerialExprM = lowerSerialExpr cppLowerConfig
        , opFoldWithNativeExprM = lowerNativeExpr cppLowerConfig
        , opFoldWithSerialArgM = genericMakeSerialArg
        , opFoldWithNativeArgM = genericMakeNativeArg
        }

    manifoldIndexer =
      makeManifoldIndexer
        (CMS.gets translatorCurrentManifold)
        (\i -> CMS.modify (\s -> s {translatorCurrentManifold = i}))

    makeSerialManifold :: SerialManifold -> SerialManifold_ PoolDocs -> CppTranslator PoolDocs
    makeSerialManifold sm (SerialManifold_ i _ form headForm e) = makeManifold i form (Just headForm) (typeMof sm) e

    makeNativeManifold :: NativeManifold -> NativeManifold_ PoolDocs -> CppTranslator PoolDocs
    makeNativeManifold nm (NativeManifold_ i _ form e) = makeManifold i form Nothing (typeMof nm) e

-- handle string interpolation
evaluatePattern :: CppTranslatorState -> TypeF -> Pattern -> [MDoc] -> MDoc
evaluatePattern _ _ (PatternText s ss) xs = "interweave_strings" <> tupled [fragments, insertions]
  where
    fragments = encloseSep "{" "}" ", " (map (dquotes . pretty) (s : ss))
    insertions = encloseSep "{" "}" ", " xs

-- handle getters
evaluatePattern _ _ (PatternStruct (ungroup -> [ss])) [m] =
  writeSelector m ss
evaluatePattern _ _ (PatternStruct (ungroup -> sss)) [m] =
  encloseSep "{" "}" "," (map (writeSelector m) sss)
evaluatePattern state0 t0 (PatternStruct s0) (m0 : xs0) =
  patternSetter makeTuple makeRecord accessTuple accessRecord m0 t0 s0 xs0
  where
    makeTuple (AppF _ ts) xs =
      let tupleTypes = CMS.evalState (mapM cppTypeOf ts) state0
       in "std::tuple" <> encloseSep "<" ">" "," tupleTypes <> tupled xs
    makeTuple _ _ = error "Unreachable"

    makeRecord _ xs = encloseSep "{" "}" ", " xs

    accessTuple _ m i = "std::get<" <> pretty i <> ">(" <> m <> ")"
    accessRecord _ d k = d <> "." <> pretty k
evaluatePattern _ _ (PatternStruct _) [] = error "Unreachable illegal pattern"

writeSelector :: MDoc -> [Either Int Text] -> MDoc
writeSelector d [] = d
writeSelector d (Right k : rs) = writeSelector (d <> "." <> pretty k) rs
writeSelector d (Left i : rs) = writeSelector ("std::get<" <> pretty i <> ">" <> parens d) rs

makeManifold ::
  (HasTypeM t) =>
  -- | The index of the manifold that is being created
  Int ->
  ManifoldForm (Or TypeS TypeF) t ->
  Maybe HeadManifoldForm ->
  -- | The type of the manifold (usually a function, serialized terms are of general type "Str" and C++ type "std::string"
  TypeM ->
  -- | Generated content for the manifold body
  PoolDocs ->
  CppTranslator PoolDocs
makeManifold callIndex form headForm manifoldType e = do
  state <- CMS.get
  let alreadyDone = manifoldHasBeenGenerated headForm state
  completeManifold <- case alreadyDone of
    True -> return $ Nothing
    False -> Just <$> makeManifoldBody (poolExpr e)
  call <- makeManifoldCall form
  return $
    e
      { poolExpr = call
      , poolCompleteManifolds = poolCompleteManifolds e <> maybeToList completeManifold
      , poolPriorLines = poolPriorLines e
      }
  where
    manifoldHasBeenGenerated :: Maybe HeadManifoldForm -> CppTranslatorState -> Bool
    manifoldHasBeenGenerated (Just HeadManifoldFormRemoteWorker) state = Set.member callIndex (translatorRemoteManifoldSet state)
    manifoldHasBeenGenerated _ state = Set.member callIndex (translatorLocalManifoldSet state)

    updateCounts :: Maybe HeadManifoldForm -> CppTranslator ()
    updateCounts (Just HeadManifoldFormRemoteWorker) = do
      state <- CMS.get
      CMS.put $
        state {translatorRemoteManifoldSet = Set.insert callIndex (translatorRemoteManifoldSet state)}
    updateCounts _ = do
      state <- CMS.get
      CMS.put $
        state {translatorLocalManifoldSet = Set.insert callIndex (translatorLocalManifoldSet state)}

    mnameExt (Just HeadManifoldFormRemoteWorker) = "_remote"
    mnameExt _ = ""

    mname = manNamer callIndex <> mnameExt headForm

    makeManifoldCall :: ManifoldForm (Or TypeS TypeF) t -> CppTranslator MDoc
    makeManifoldCall (ManifoldFull rs) = do
      let args = map argNamer (typeMofRs rs)
      return $ mname <> tupled args
    makeManifoldCall (ManifoldPass _) = return mname
    makeManifoldCall (ManifoldPart rs vs) = do
      let vs' =
            take
              (length vs)
              (map (\j -> "std::placeholders::_" <> viaShow j) ([1 ..] :: [Int]))
          rs' = map argNamer (typeMofRs rs)
          bindStr = stdBind $ mname : (rs' ++ vs')
      return bindStr

    makeManifoldBody :: MDoc -> CppTranslator MDoc
    makeManifoldBody body = do
      updateCounts headForm
      returnTypeStr <- returnType manifoldType
      let argList = typeMofForm form
      args <- mapM (\r@(Arg _ t) -> cppArgOf (chooseCallSemantics t) r) argList
      let decl = returnTypeStr <+> mname <> tupled args
      let tryBody = block 4 "try" body
          throwStatement =
            vsep
              [ [idoc|std::string error_message = "Error raised in C++ pool by m#{pretty callIndex}:\n" + std::string(e.what());|]
              , [idoc|throw std::runtime_error(error_message);|]
              ]
          catchBody = block 4 "catch (const std::exception& e)" throwStatement
          tryCatchBody = tryBody <+> catchBody
      return . block 4 decl . vsep $
        [ {- can add diagnostic statements here -}
          tryCatchBody
        ]

    returnType :: TypeM -> CppTranslator MDoc
    returnType (Function _ t) = cppTypeOf t
    returnType t = cppTypeOf t

stdBind :: [MDoc] -> MDoc
stdBind xs = [idoc|std::bind(#{args})|]
  where
    args = cat (punctuate "," xs)

makeDispatch :: [SerialManifold] -> MDoc
makeDispatch ms =
  [idoc|uint8_t* local_dispatch(uint32_t mid, const uint8_t** args){
    switch(mid){
        #{align (vsep localCases)}
        default:
            std::ostringstream oss;
            oss << "Invalid local manifold id: " << mid;
            throw std::runtime_error(oss.str());
    }
}

uint8_t* remote_dispatch(uint32_t mid, const uint8_t** args){
    switch(mid){
        #{align (vsep remoteCases)}
        default:
            std::ostringstream oss;
            oss << "Invalid remote manifold id: " << mid;
            throw std::runtime_error(oss.str());
    }
}|]
  where
    localCases = catMaybes $ map localCase ms

    localCase :: SerialManifold -> Maybe MDoc
    localCase (SerialManifold _ _ _ HeadManifoldFormRemoteWorker _) = Nothing
    localCase (SerialManifold i _ form _ _) = Just $ makeCase "" (i, getSize form)

    getSize :: ManifoldForm (Or TypeS TypeF) TypeS -> Int
    getSize = sum . abilist (\_ _ -> 1) (\_ _ -> 1)

    remoteCases :: [MDoc]
    remoteCases = map (makeCase "_remote") . unique . concat $ map getRemotes ms

    makeCase :: MDoc -> (Int, Int) -> MDoc
    makeCase suffix (i, n) =
      "case" <+> pretty i
        <> ":"
          <+> "return"
          <+> manNamer i
        <> suffix
        <> tupled ["args[" <> pretty j <> "]" | j <- take n ([0 ..] :: [Int])]
        <> ";"

    getRemotes :: SerialManifold -> [(Int, Int)]
    getRemotes = MM.runIdentity . foldSerialManifoldM (defaultValue {opSerialExprM = getRemoteSE})

    getRemoteSE ::
      SerialExpr_ [(Int, Int)] [(Int, Int)] [(Int, Int)] [(Int, Int)] [(Int, Int)] ->
      MM.Identity [(Int, Int)]
    getRemoteSE (AppPoolS_ _ (PoolCall i _ (RemoteCall _) _) xss) = return $ (i, length xss) : concat xss
    getRemoteSE x = return $ foldlSE mappend mempty x

typeParams :: [(Maybe TypeF, TypeF)] -> CppTranslator MDoc
typeParams ts = recordTemplate <$> mapM cppTypeOf [t | (Nothing, t) <- ts]

collectRecords :: SerialManifold -> [(FVar, Int, [(Key, TypeF)])]
collectRecords e0@(SerialManifold i0 _ _ _ _) =
  unique $ CMS.evalState (surroundFoldSerialManifoldM manifoldIndexer fm e0) i0
  where
    fm = defaultValue {opFoldWithNativeExprM = nativeExpr, opFoldWithSerialExprM = serialExpr}

    manifoldIndexer = makeManifoldIndexer CMS.get CMS.put

    nativeExpr _ (DeserializeN_ t s xs) = do
      manifoldIndex <- CMS.get
      let tRecs = seekRecs manifoldIndex t
          sRecs = seekRecs manifoldIndex (serialAstToType s)
      return $ xs <> tRecs <> sRecs
    nativeExpr efull e = do
      manifoldIndex <- CMS.get
      let newRecs = seekRecs manifoldIndex (typeFof efull)
      return $ foldlNE (<>) newRecs e

    serialExpr _ (SerializeS_ s xs) = do
      manifoldIndex <- CMS.get
      return $ seekRecs manifoldIndex (serialAstToType s) <> xs
    serialExpr _ e = return $ foldlSE (<>) [] e

    seekRecs :: Int -> TypeF -> [(FVar, Int, [(Key, TypeF)])]
    seekRecs m (NamF _ v@(FV _ (CV "struct")) _ rs) = [(v, m, rs)] <> concatMap (seekRecs m . snd) rs
    seekRecs m (NamF _ _ _ rs) = concatMap (seekRecs m . snd) rs
    seekRecs m (FunF ts t) = concatMap (seekRecs m) (t : ts)
    seekRecs m (AppF t ts) = concatMap (seekRecs m) (t : ts)
    seekRecs _ (UnkF _) = []
    seekRecs _ (VarF _) = []

-- unify records with the same name/keys
unifyRecords ::
  [ ( FVar -- The "v" in (NamP _ v@(PV _ _ "struct") _ rs)
    , Int -- general index
    , [(Key, TypeF)] -- key/type terms for this record
    )
  ] ->
  RecMap
unifyRecords xs =
  zipWith (\i ((v, ks), es) -> ((v, ks), RecEntry (structName i v) es)) [1 ..]
    . map (\((v, ks), rss) -> ((v, ks), map unifyField (transpose (map snd rss))))
    -- associate unique pairs of record name and keys with their edge types
    . groupSort
    . unique
    $ [((v, map fst es), (m, es)) | (v, m, es) <- xs]

structName :: Int -> FVar -> MDoc
structName i (FV v (CV "struct")) = "mlc_" <> pretty v <> "_" <> pretty i
structName _ (FV _ v) = pretty v

unifyField :: [(Key, TypeF)] -> (Key, Maybe TypeF)
unifyField [] = error "Empty field"
unifyField rs@((v, _) : _)
  | not (all ((== v) . fst) rs) =
      error $ "Bad record - unequal fields: " <> show (unique rs)
  | otherwise = case unique (map snd rs) of
      [t] -> (v, Just t)
      _ -> (v, Nothing)

generateAnonymousStructs :: CppTranslator ([MDoc], [MDoc])
generateAnonymousStructs = do
  recmap <- CMS.gets translatorRecmap

  xs <- mapM makeSerializers (reverse . map snd $ recmap)

  return (concatMap fst xs, concatMap snd xs)
  where
    makeSerializers :: RecEntry -> CppTranslator ([MDoc], [MDoc])
    makeSerializers rec = do
      let templateTerms = map (("T" <>) . pretty) ([1 ..] :: [Int])
          rs' = zip templateTerms (recFields rec)

      let params = [t | (t, (_, Nothing)) <- rs']
          rname = recName rec
          rtype = rname <> recordTemplate [v | (v, (_, Nothing)) <- rs']

      let fieldNames = [k | (_, (k, _)) <- rs']

      fieldTypes <- mapM (\(t, v) -> maybeM t cppTypeOf v) [(t', v') | (t', (_, v')) <- rs']

      let fields = [(pretty k, v) | (k, v) <- zip fieldNames fieldTypes]

      let structDecl = structTypedefTemplate params rname fields
          serializer = serializerTemplate params rtype fields
          deserializer = deserializerTemplate False params rtype fields

      return ([structDecl], [serializer, deserializer])

    -- monadic form of `maybe` function
    maybeM :: (Monad m) => a -> (b -> m a) -> Maybe b -> m a
    maybeM _ f (Just x) = f x
    maybeM x _ Nothing = return x

generateSourcedSerializers ::
  Map.Map Lang Scope ->
  GMap Int MVar (Map.Map Lang Scope) ->
  [SerialManifold] -> -- all segments that can be called in this pool
  CppTranslator
    ( [MDoc]
    , [MDoc]
    )
generateSourcedSerializers univeralScopeMap scopeMap es0 = do
  -- find the scopes that are used in this manifold
  -- we need to generate (de)serializers for all records
  typedef <- Map.unions <$> mapM (foldSerialManifoldM fm) es0

  scope <- case Map.lookup CppLang univeralScopeMap of
    (Just scope) -> return scope
    Nothing -> return Map.empty

  foldl groupQuad ([], []) . concat . Map.elems <$> Map.mapWithKeyM (makeSerials scope) typedef
  where
    -- given the universal map of scopes, pull out every one that is used in this subtree
    fm =
      defaultValue
        { opSerialManifoldM = \(SerialManifold_ i _ _ _ e) -> return $ Map.unionWith mergeScopes (metaTypedefs scopeMap i) e
        , opNativeManifoldM = \(NativeManifold_ i _ _ e) -> return $ Map.unionWith mergeScopes (metaTypedefs scopeMap i) e
        }

    -- there are likely to be repeats in the scopes, we only want the unique ones
    mergeScopes xs ys = unique (xs <> ys)

    groupQuad :: ([a], [a]) -> (a, a) -> ([a], [a])
    groupQuad (xs, ys) (x, y) = (x : xs, y : ys)

    makeSerials ::
      Scope -> TVar -> [([Either TVar TypeU], TypeU, ArgDoc, Bool)] -> CppTranslator [(MDoc, MDoc)]
    makeSerials s v xs = catMaybes <$> mapM (makeSerial s v) xs

    makeSerial ::
      Scope -> TVar -> ([Either TVar TypeU], TypeU, ArgDoc, Bool) -> CppTranslator (Maybe (MDoc, MDoc))
    makeSerial _ _ (_, NamU _ (TV "struct") _ _, _, _) = return Nothing
    makeSerial scope _ (ps, NamU r (TV v) _ rs, _, _) = do
      params <- mapM (either (\p -> return $ "T" <> pretty p) (\_ -> return "XXX_FIXME")) ps
      let templateTerms = ["T" <> pretty p | Left p <- ps]
          rtype = pretty v <> recordTemplate templateTerms
          rs' = map (second (evaluateTypeU scope)) rs
          fields = [(pretty k, showDefType ps (typeOf t)) | (k, t) <- rs']
          serializer = serializerTemplate params rtype fields
          deserializer = deserializerTemplate (r == NamObject) params rtype fields
      return $ Just (serializer, deserializer)
    makeSerial _ _ _ = return Nothing

    evaluateTypeU :: Scope -> TypeU -> TypeU
    evaluateTypeU scope t = case TE.evaluateType scope t of
      (Left e) -> error $ show e
      (Right t') -> t'

    showDefType :: [Either TVar TypeU] -> Type -> MDoc
    showDefType ps (UnkT v)
      | (Left v) `elem` ps = "T" <> pretty v
      | otherwise = pretty v
    showDefType ps (VarT v)
      | (Left v) `elem` ps = "T" <> pretty v
      | otherwise = pretty v
    showDefType _ (FunT _ _) = error "Cannot serialize functions"
    showDefType _ (NamT _ v _ _) = pretty v
    showDefType ps (AppT (VarT (TV v)) ts) = pretty $ expandMacro v (map (render . showDefType ps) ts)
    showDefType _ (AppT _ _) = error "AppT is only OK with VarT, for now"

makeTemplateHeader :: [MDoc] -> MDoc
makeTemplateHeader [] = ""
makeTemplateHeader ts = "template" <+> encloseSep "<" ">" "," ["class" <+> t | t <- ts]

recordTemplate :: [MDoc] -> MDoc
recordTemplate [] = ""
recordTemplate ts = encloseSep "<" ">" "," ts

-- Example
-- > template <class T>
-- > struct Person
-- > {
-- >     std::vector<std::string> name;
-- >     std::vector<T> info;
-- > };
structTypedefTemplate ::
  [MDoc] -> -- template parameters (e.g., ["T"])
  MDoc -> -- the name of the structure (e.g., "Person")
  [(MDoc, MDoc)] -> -- key and type for all fields
  MDoc -- structure definition
structTypedefTemplate params rname fields = vsep [template, struct]
  where
    template = makeTemplateHeader params
    struct =
      block
        4
        ("struct" <+> rname)
        (vsep [t <+> k <> ";" | (k, t) <- fields])
        <> ";"

serializerTemplate ::
  [MDoc] -> -- template parameters
  MDoc -> -- type of thing being serialized
  [(MDoc, MDoc)] -> -- key and type for all fields
  MDoc -- output serializer function
serializerTemplate params rtype fields =
  [idoc|
#{makeTemplateHeader params}
void* toAnything(void* dest, void** cursor, const Schema* schema, const #{rtype}& obj)
{
    return toAnything(dest, cursor, schema, std::make_tuple#{arguments});
}
|]
  where
    arguments = tupled ["obj." <> key | (key, _) <- fields]

deserializerTemplate ::
  Bool -> -- build object with constructor -- TODO: isObj, bring this back

  -- | template parameters
  [MDoc] ->
  -- | type of thing being deserialized
  MDoc ->
  -- | key and type for all fields
  [(MDoc, MDoc)] ->
  -- | output deserializer function
  MDoc
deserializerTemplate _ params rtype fields =
  [idoc|
#{makeTemplateHeader params}
#{block 4 header body}

#{makeTemplateHeader params}
#{block 4 headerGetSize bodyGetSize}
|]
  where
    header =
      [idoc|#{rtype} fromAnything(const Schema* schema, const void * anything, #{rtype}* dummy = nullptr)|]
    body =
      vsep $
        [[idoc|#{rtype} obj;|]]
          <> zipWith assignFields [0 ..] fields
          <> ["return obj;"]

    assignFields :: Int -> (MDoc, MDoc) -> MDoc
    assignFields idx (keyName, keyType) =
      vsep
        [ [idoc|#{keyType}* elemental_dumby_#{keyName} = nullptr;|]
        , [idoc|obj.#{keyName} = fromAnything(schema->parameters[#{pretty idx}], (char*)anything + schema->offsets[#{pretty idx}], elemental_dumby_#{keyName});|]
        ]

    headerGetSize = [idoc|size_t get_shm_size(const Schema* schema, const #{rtype}& data)|]
    bodyGetSize =
      vsep $
        ["size_t size = 0;"]
          <> [getSize idx key | (idx, (key, _)) <- zip [0 ..] fields]
          <> ["return size;"]

    getSize :: Int -> MDoc -> MDoc
    getSize idx key = [idoc|size += get_shm_size(schema->parameters[#{pretty idx}], data.#{key});|]

-- XXX: here need to add back the isObj handling, if is object, need to call
-- the constructor rather than directly assigning to fields

makeMain :: [MDoc] -> [MDoc] -> [MDoc] -> [MDoc] -> MDoc -> MDoc
makeMain includes signatures serialization manifolds dispatch =
  format
    (DF.embededFileText (DF.poolTemplate CppLang))
    "// <<<BREAK>>>"
    [ vsep includes
    , vsep serialization
    , vsep signatures
    , vsep manifolds
    , dispatch
    ]
