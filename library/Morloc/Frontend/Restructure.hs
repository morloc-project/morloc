{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ViewPatterns #-}
{-# LANGUAGE TupleSections #-}

{- |
Module      : Morloc.Frontend.Restructure
Description : Write Module objects to resolve type aliases and such
Copyright   : (c) Zebulun Arendsee, 2016-2026
License     : Apache-2.0
Maintainer  : z@morloc.io
-}
module Morloc.Frontend.Restructure (restructure) where

import Data.Set (Set)
import qualified Data.Set as Set
import Data.Text (Text)
import qualified Morloc.Data.DAG as DAG
import Morloc.Data.Doc
import qualified Morloc.Data.GMap as GMap
import qualified Morloc.Data.Map as Map
import qualified Morloc.Data.Text as MT
import qualified Morloc.Frontend.AST as AST
import Morloc.Frontend.Namespace
import qualified Morloc.Monad as MM

-- | Resolve type aliases, term aliases and import/exports
restructure ::
  DAG MVar Import ExprI ->
  MorlocMonad (DAG MVar [AliasedSymbol] ExprI)
restructure s = do
  -- Set the counter for reindexing expressions.
  --
  -- This is the first use of the morloc state counter. The indices currently
  -- in the tree were generated by the lexer state counter. So now we need
  -- to find the largest index in the tree and resume counting from there.
  -- Since d is the entire tree, the initizalized counter will start at global maximum.
  MM.setCounter $ maximum (map AST.maxIndex (DAG.nodes s)) + 1

  checkForSelfRecursion s -- currently, do no not allow type self-recursion
    >>= resolveImports -- rewrite DAG edges to map imported terms to their aliases
    >>= handleBinops -- first resolve binary operators
    >>= resolveHoles -- then holes
      |>> handleTypeDeclarations
    >>= doM collectTags
    >>= doM collectTypes
    >>= (\x -> collectUniversalTypes >> return x)
    >>= doM collectSources

doM :: (Monad m) => (a -> m ()) -> a -> m a
doM f x = f x >> return x

{- | Check for infinitely expanding self-recursive types

There are cases were the defined term may appear on the right. For example:

  type Py (Tree n e l) = "Tree" n e l

Here the general type Tree is mapped to the concrete type "Tree" in Python.
The fact that the general and concrete names are the same is fine. They are
different languages. But what about:

  type (Tree n) = Node n [Tree n]

This type should be legal, but currently it is not supported. Which
is why I need to raise an explicit error to avoid infinite loops.
-}
checkForSelfRecursion :: DAG k e ExprI -> MorlocMonad (DAG k e ExprI)
checkForSelfRecursion d = do
  _ <- DAG.mapNodeM (AST.checkExprI isExprSelfRecursive) d
  return d
  where
    -- A typedef is self-recursive if its name appears in its definition
    isExprSelfRecursive :: ExprI -> MorlocMonad ()
    -- Allow general type existence statements without parameters
    isExprSelfRecursive (ExprI _ (TypE (ExprTypeE Nothing _ [] _ _))) = return ()
    --  and also with parameters
    isExprSelfRecursive (ExprI _ (TypE (ExprTypeE Nothing v vs t _)))
      | t == AppU (VarU v) (map (either VarU id) vs) = return ()
      | hasTerm v t = MM.throwError . SelfRecursiveTypeAlias $ v
      | otherwise = return ()
    -- otherwise disallow self-recursion
    isExprSelfRecursive (ExprI _ (TypE (ExprTypeE _ v ts t _)))
      | any (hasTerm v) (t : (rights ts)) = MM.throwError . SelfRecursiveTypeAlias $ v
      | otherwise = return ()
    isExprSelfRecursive _ = return ()

    -- check if a given term appears in a type
    hasTerm :: TVar -> TypeU -> Bool
    hasTerm v (VarU v') = v == v'
    hasTerm v (ForallU _ t) = hasTerm v t
    hasTerm v (FunU (t1 : rs) t2) = hasTerm v t1 || hasTerm v (FunU rs t2)
    hasTerm v (FunU [] t) = hasTerm v t
    hasTerm v (AppU t1 (t2 : rs)) = hasTerm v t2 || hasTerm v (AppU t1 rs)
    hasTerm v (AppU t1 []) = hasTerm v t1
    hasTerm v (NamU o n ps ((_, t) : rs)) = hasTerm v t || hasTerm v (NamU o n ps rs)
    hasTerm v (NamU o n (p : ps) []) = hasTerm v p || hasTerm v (NamU o n ps [])
    hasTerm _ (NamU _ _ [] []) = False
    hasTerm _ ExistU {} = error "There should not be existentionals in typedefs"

maybeM :: MorlocError -> Maybe a -> MorlocMonad a
maybeM _ (Just x) = return x
maybeM e Nothing = MM.throwError e

resolveHoles ::
  DAG MVar [AliasedSymbol] ExprI ->
  MorlocMonad (DAG MVar [AliasedSymbol] ExprI)
resolveHoles = DAG.mapNodeM unhole
  where
    unhole :: ExprI -> MorlocMonad ExprI
    unhole e@(ExprI _ (LstE _)) = unholeContainer e
    unhole e@(ExprI _ (TupE _)) = unholeContainer e
    unhole e@(ExprI _ (NamE _)) = unholeContainer e
    unhole (ExprI i (AppE e0 es0)) =
      case length [HolE | (ExprI _ HolE) <- es0] of
        0 -> AppE <$> unhole e0 <*> mapM unhole es0 |>> ExprI i
        n -> do
          lambdaIndex <- MM.getCounter
          let vs = map (nameHole lambdaIndex) [1 .. n]
              (_, es) = statefulMap insertHole vs es0
          newApp <- AppE <$> unhole e0 <*> mapM unhole es
          return $ ExprI lambdaIndex (LamE vs (ExprI i newApp))
      where
        insertHole :: [EVar] -> ExprI -> ([EVar], ExprI)
        insertHole (v : vs) (ExprI j HolE) = (vs, ExprI j (VarE defaultValue v))
        insertHole vs e = (vs, e)
    -- simple recursion
    unhole (ExprI i (ModE m es)) = ModE m <$> mapM unhole es |>> ExprI i
    unhole (ExprI i (IstE c ts es)) = IstE c ts <$> mapM unhole es |>> ExprI i
    unhole (ExprI i (AssE v e es)) = AssE v <$> unhole e <*> mapM unhole es |>> ExprI i
    unhole (ExprI i (HolE)) = return HolE |>> ExprI i
    unhole (ExprI i (LamE vs e)) = LamE vs <$> unhole e |>> ExprI i
    unhole (ExprI i (AnnE e t)) = AnnE <$> unhole e <*> pure t |>> ExprI i
    unhole (ExprI _ (BopE _ _ _ _)) = error "Bop should have been resolved"
    unhole e = return e

    unholeContainer :: ExprI -> MorlocMonad ExprI
    unholeContainer e0@(ExprI i0 _) =
      case countHoles e0 of
        0 -> descend e0
        n -> do
          let vs = map (nameHole i0) [1 .. n]
          e <- descend . snd . insertHoles vs $ e0
          MM.sayVVV $ "unholeContainer vs:" <+> list (map pretty vs)
          MM.sayVVV $ "unholeContainer e:" <+> pretty e
          return $ ExprI i0 (LamE vs e)
          where
            insertHoles :: [EVar] -> ExprI -> ([EVar], ExprI)
            insertHoles (v : vs) (ExprI i HolE) = (vs, ExprI i (VarE defaultValue v))
            insertHoles vs (ExprI i (LstE es)) =
              let (vs', es') = statefulMap insertHoles vs es
               in (vs', ExprI i (LstE es'))
            insertHoles vs (ExprI i (TupE es)) =
              let (vs', es') = statefulMap insertHoles vs es
               in (vs', ExprI i (TupE es'))
            insertHoles vs (ExprI i (NamE (unzip -> (ks, es)))) =
              let (vs', es') = statefulMap insertHoles vs es
               in (vs', ExprI i (NamE (zip ks es')))
            insertHoles vs e = (vs, e)

    countHoles :: ExprI -> Int
    countHoles (ExprI _ HolE) = 1
    countHoles (ExprI _ (LstE xs)) = sum (map countHoles xs)
    countHoles (ExprI _ (TupE xs)) = sum (map countHoles xs)
    countHoles (ExprI _ (NamE (map snd -> xs))) = sum (map countHoles xs)
    countHoles _ = 0

    descend :: ExprI -> MorlocMonad ExprI
    -- refresh
    descend e@(ExprI _ (AppE _ _)) = unhole e
    -- simple recurse
    descend (ExprI i (LamE vs e)) = LamE vs <$> descend e |>> ExprI i
    descend (ExprI i (LstE es)) = LstE <$> mapM descend es |>> ExprI i
    descend (ExprI i (TupE es)) = TupE <$> mapM descend es |>> ExprI i
    descend (ExprI i (NamE rs)) = NamE <$> mapM (\(k, e) -> (,) k <$> descend e) rs |>> ExprI i
    descend (ExprI i (AnnE e t)) = AnnE <$> descend e <*> pure t |>> ExprI i
    descend e = return e

    -- name a hole based on the index of the new lambda and the hole position
    nameHole :: Int -> Int -> EVar
    nameHole lidx aidx = EV ("_hole" <> MT.show' lidx <> "_" <> MT.show' aidx)

{- | Use export/import information to find which terms are imported into each module
* reduces the Import edge type to an alias map.
* replaces Export terms in expressions
-}
resolveImports ::
  DAG MVar Import ExprI ->
  MorlocMonad (DAG MVar [AliasedSymbol] ExprI)
resolveImports d0 =
  DAG.synthesize resolveExports resolveEdge d0
    >>= maybeM (CyclicDependency "cyclical import dependency in resolveImports")
  where
    -- Collect all exported terms from a module (including those imported
    -- without qualification. Then update the ExpE term
    resolveExports :: MVar -> ExprI -> [(MVar, Import, ExprI)] -> MorlocMonad ExprI
    resolveExports m e children = do
      let allLocalSymbols = findSymbols e -- Set Symbol
          export = AST.findExport e -- Export
      allImportedSymbols <-
        Set.unions <$> mapM (\(_, imp', expr') -> filterImports m imp' (AST.findExport expr')) children

      let allSymbols = Set.union allLocalSymbols allImportedSymbols

      exports <- case export of
        ExportAll -> mapM addIndex (Set.toList allSymbols) |>> Set.fromList
        (ExportMany (resolveExplicitTypeclasses allSymbols -> explicitExports)) ->
          let missing = (Set.map snd explicitExports) `Set.difference` allSymbols
           in if Set.null missing
                then
                  return explicitExports -- all things exported are defined
                else
                  MM.throwError . ImportExportError m . render $
                    "Module does not export the following terms or types:"
                      <+> list (map viaShow (Set.toList missing))

      return $ AST.setExport (ExportMany exports) e

    resolveExplicitTypeclasses :: Set Symbol -> Set (Int, Symbol) -> Set (Int, Symbol)
    resolveExplicitTypeclasses ss sis = Set.map f sis
      where
        f :: (Int, Symbol) -> (Int, Symbol)
        f (i, TypeSymbol (TV x))
          | (ClassSymbol (ClassName x)) `Set.member` ss = (i, ClassSymbol (ClassName x))
          | otherwise = (i, TypeSymbol (TV x))
        f x = x

    addIndex :: a -> MorlocMonad (Int, a)
    addIndex x = (,) <$> MM.getCounter <*> pure x

    -- TODO: distinguish between these expressions at the type-level
    --       the contains unresolved imports, that later resolved
    resolveEdge ::
      Import ->
      ExprI -> -- importing module expression (with resolved exports)
      ExprI -> -- imported module expression  (with resolved exports)
      MorlocMonad [AliasedSymbol]
    resolveEdge imp _ childX = case (importInclude imp, AST.findExport childX) of
      (_, ExportAll) -> error "This should have been resolved already"
      (Nothing, ExportMany exps) -> return $ map (toAliasedSymbol . snd) (Set.toList exps)
      (Just ass, ExportMany exps) -> return . catMaybes $ map (importAlias . unAliasedSymbol) ass
        where
          exportMap = Map.fromList [(unSymbol s, s) | (_, s) <- Set.toList exps]
          excludes = map unSymbol (importExclude imp)

          importAlias :: (Text, Text) -> Maybe AliasedSymbol
          importAlias (name, alias)
            | name `elem` excludes = Nothing
            | otherwise = case Map.lookup name exportMap of
                Nothing -> Nothing
                (Just (TermSymbol _)) -> Just $ AliasedTerm (EV name) (EV alias)
                (Just (TypeSymbol _)) -> Just $ AliasedType (TV name) (TV alias)
                (Just (ClassSymbol _)) -> Just $ AliasedClass (ClassName name)

    filterImports ::
      MVar ->
      Import -> -- the current node import list
      Export -> -- the imported modules export list
      MorlocMonad (Set Symbol)
    -- Here we import everything outside the exclude set, no aliasing
    filterImports _ (Import _ Nothing exclude _) (ExportMany exports) =
      return $ (Set.map snd exports) `Set.difference` (Set.fromList exclude)
    -- Here we need to carefully handle aliasing
    filterImports m1 (Import m2 (Just as) (map unSymbol -> exclude) _) (ExportMany exports) =
      case partitionEithers . catMaybes $ map importAlias (map unAliasedSymbol as) of
        ([], imps) -> return $ Set.fromList imps
        (missing, _) ->
          MM.throwError . ImportExportError m1 $
            "The following imported terms are not exported from module '"
              <> unMVar m2
              <> "': "
              <> render (list $ map pretty missing)
      where
        exportMap = Map.fromList [(unSymbol s, s) | (_, s) <- Set.toList exports]

        importAlias :: (Text, Text) -> Maybe (Either Text Symbol)
        importAlias (name, alias)
          | name `elem` exclude = Nothing
          | otherwise = case Map.lookup name exportMap of
              Nothing -> Just (Left name)
              (Just (TermSymbol _)) -> Just . Right $ TermSymbol (EV alias)
              (Just (TypeSymbol _)) -> Just . Right $ TypeSymbol (TV alias)
              (Just (ClassSymbol _)) -> Just . Right $ ClassSymbol (ClassName alias)
    filterImports _ _ _ = error "Unreachable -- all Export values should have been converted to ExportMany"

    findSymbols :: ExprI -> Set Symbol
    findSymbols (ExprI _ (ModE _ es)) = Set.unions (map findSymbols es)
    findSymbols (ExprI _ (TypE (ExprTypeE _ v _ _ _))) = Set.singleton $ TypeSymbol v
    findSymbols (ExprI _ (AssE e _ _)) = Set.singleton $ TermSymbol e
    findSymbols (ExprI _ (ClsE (Typeclass cls _ _))) = Set.singleton $ ClassSymbol cls
    findSymbols (ExprI _ (SigE (Signature e _ _))) = Set.singleton $ TermSymbol e
    findSymbols (ExprI _ (SrcE src)) = Set.singleton $ TermSymbol (srcAlias src)
    -- The definition of an instance does not automatically imply export or make
    -- the values available. The instance is ALWAYS relative to the class
    -- definition (either local or imported).
    findSymbols (ExprI _ (IstE cls _ _)) = Set.singleton $ ClassSymbol cls
    findSymbols _ = Set.empty

    unSymbol :: Symbol -> Text
    unSymbol (TypeSymbol (TV v)) = v
    unSymbol (TermSymbol (EV v)) = v
    unSymbol (ClassSymbol (ClassName v)) = v

    unAliasedSymbol :: AliasedSymbol -> (Text, Text)
    unAliasedSymbol (AliasedType x y) = (unTVar x, unTVar y)
    unAliasedSymbol (AliasedTerm x y) = (unEVar x, unEVar y)
    unAliasedSymbol (AliasedClass x) = (unClassName x, unClassName x)

    toAliasedSymbol :: Symbol -> AliasedSymbol
    toAliasedSymbol (TypeSymbol x) = AliasedType x x
    toAliasedSymbol (TermSymbol x) = AliasedTerm x x
    toAliasedSymbol (ClassSymbol x) = AliasedClass x

handleTypeDeclarations ::
  DAG k e ExprI ->
  DAG k e ExprI
handleTypeDeclarations = DAG.mapNode f
  where
    f (ExprI i (ModE m es)) = ExprI i (ModE m (filter isNotSelfDef es))
    f e = e

    isNotSelfDef :: ExprI -> Bool
    isNotSelfDef (ExprI _ (TypE (ExprTypeE Nothing v [] (VarU v') _))) = v /= v'
    isNotSelfDef (ExprI _ (TypE (ExprTypeE Nothing (VarU -> v) (map (either VarU id) -> vs) (AppU v' vs') _))) =
      v /= v' || length vs /= length vs' || not (all (uncurry (==)) (zip vs vs'))
    isNotSelfDef _ = True


handleBinops :: DAG MVar [AliasedSymbol] ExprI -> MorlocMonad (DAG MVar [AliasedSymbol] ExprI)
handleBinops d0 = do
  mayN <- DAG.synthesize updateNode (\e _ _ -> return e) d0
  case mayN of
    (Just e') -> return $ DAG.mapNode fst e'
    Nothing -> error "Unreachable?"
  where
    updateNode ::
      MVar ->
      ExprI ->
      [(MVar, [AliasedSymbol], (ExprI, Map.Map EVar (Associativity, Int)))] ->
      MorlocMonad (ExprI, Map.Map EVar (Associativity, Int))
    updateNode _ e es = do
      thisFixityMap <- AST.findFixityMap e
      fixityMap <- mergeFixityMaps $ thisFixityMap : [filterTerms m ss | (_, ss, (_, m)) <- es]
      e' <- updateBinopExprs fixityMap e
      return (e', fixityMap)

    -- TODO - This should filter the inherited fixity definitions that are both
    -- directly inherited and those from typeclasses. Currently I just inherit
    -- everything.
    filterTerms :: Map.Map EVar a -> [AliasedSymbol] -> Map.Map EVar a
    filterTerms m ss = m
      -- let symMap = Map.fromList [(k, v) | (AliasedTerm k v) <- ss]
      --  in Map.fromList . catMaybes $ [Map.lookup k symMap |>> (, v) | (k, v) <- Map.toList m]

    mergeFixityMaps :: Eq a => [Map.Map EVar a] -> MorlocMonad (Map.Map EVar a)
    mergeFixityMaps [] = return Map.empty
    mergeFixityMaps [e1] = return e1
    mergeFixityMaps (e1:e2:es) = do
      e' <- foldlM strictInsert e1 (Map.toList e2)
      mergeFixityMaps (e':es)

    strictInsert :: Eq v => Map.Map EVar v -> (EVar, v) -> MorlocMonad (Map.Map EVar v)
    strictInsert m (k, v) = case Map.lookup k m of
      Nothing -> return $ Map.insert k v m
      (Just v') -> if v == v'
                   then return m
                   else MM.throwError . ConflictingFixity $ k

    updateBinopExprs :: Map.Map EVar (Associativity, Int) -> ExprI -> MorlocMonad ExprI
    updateBinopExprs m0 = f where
      f e@(ExprI _ BopE{}) = resolveBinop m0 e >>= f
      f (ExprI i (ModE m es)) = ModE m <$> mapM f es |>> ExprI i
      f (ExprI i (IstE cls ts es)) = IstE cls ts <$> mapM f es |>> ExprI i
      f (ExprI i (AssE v e es)) = AssE v <$> f e <*> mapM f es |>> ExprI i
      f (ExprI i (LstE es)) = LstE <$> mapM f es |>> ExprI i
      f (ExprI i (TupE es)) = TupE <$> mapM f es |>> ExprI i
      f (ExprI i (NamE rs)) = do
        es' <- mapM (f . snd) rs
        return $ ExprI i (NamE (zip (map fst rs) es'))
      f (ExprI i (AppE e es)) = AppE <$> f e <*> mapM f es |>> ExprI i
      f (ExprI i (LamE vs e)) = LamE vs <$> f e |>> ExprI i
      f (ExprI i (AnnE e t)) = AnnE <$> f e <*> pure t |>> ExprI i
      f e = return e

    -- | Rewrite a right-nested BopE chain into a correctly-associated AppE tree.
    -- Uses the Pratt (precedence climbing) algorithm.
    -- Operators not in fixMap default to infixl 9.
    resolveBinop :: Map.Map EVar (Associativity, Int) -> ExprI -> MorlocMonad ExprI
    resolveBinop fixMap expr = do
      let (lhs0, ops) = flatten expr
      (result, _) <- pratt 0 lhs0 ops
      return result
      where
        lookupFixity :: EVar -> (Associativity, Int)
        lookupFixity v = Map.findWithDefault (InfixL, 9) v fixMap

        -- Walk the right spine of BopE nodes into a flat list.
        -- Each entry: (outerIdx, opIdx, opName, rightOperand)
        flatten :: ExprI -> (ExprI, [(Int, Int, EVar, ExprI)])
        flatten (ExprI outerI (BopE lhs opI op rhs)) =
          let (rhsFirst, rhsRest) = flatten rhs
           in (lhs, (outerI, opI, op, rhsFirst) : rhsRest)
        flatten e = (e, [])

        -- Pratt loop: consume operators with prec >= minPrec.
        -- Returns the parsed lhs and the unconsumed tail.
        pratt :: Int -> ExprI -> [(Int, Int, EVar, ExprI)] -> MorlocMonad (ExprI, [(Int, Int, EVar, ExprI)])
        pratt _ lhs [] = return (lhs, [])
        pratt minPrec lhs ((outerI, opI, op, rhs) : rest) = do
          let (assoc, prec) = lookupFixity op
          if prec < minPrec
            then return (lhs, (outerI, opI, op, rhs) : rest)
            else do
              let nextMinPrec = if assoc == InfixR then prec else prec + 1
              (rhsParsed, remaining) <- pratt nextMinPrec rhs rest
              -- Ambiguity check: incompatible fixities at the same precedence
              case remaining of
                ((_, _, nextOp, _) : _) -> do
                  let (nextAssoc, nextPrec) = lookupFixity nextOp
                  when (nextPrec == prec && (assoc /= nextAssoc || assoc == InfixN))
                       (MM.throwError $ AmbiguousOperators op nextOp)
                [] -> return ()
              let lhs' = ExprI outerI $ AppE (ExprI opI (VarE defaultValue op)) [lhs, rhsParsed]
              pratt minPrec lhs' remaining

collectTags :: DAG MVar [AliasedSymbol] ExprI -> MorlocMonad ()
collectTags fullDag = do
  _ <- DAG.mapNodeM f fullDag
  return ()
  where
    -- \* add ManifoldConfigs associated with VarE types to MorlocMonad state
    -- \* the configs store the metadata associated with the term tags
    -- \* later we use the manifold indices to lookup things like runtime info
    --   (threads required and such)
    f :: ExprI -> MorlocMonad ()
    f (ExprI i (VarE config _)) = do
      s <- MM.get
      MM.put (s {stateManifoldConfig = Map.insert i config (stateManifoldConfig s)})
    f (ExprI _ (ModE _ es)) = mapM_ f es
    f (ExprI _ (IstE _ _ es)) = mapM_ f es
    f (ExprI _ (AssE _ e es)) = mapM_ f (e : es)
    f (ExprI _ (LstE es)) = mapM_ f es
    f (ExprI _ (TupE es)) = mapM_ f es
    f (ExprI _ (NamE rs)) = mapM_ (f . snd) rs
    f (ExprI _ (AppE e es)) = mapM_ f (e : es)
    f (ExprI _ (LamE _ e)) = f e
    f (ExprI _ (AnnE e _)) = f e
    f _ = return ()

type GCMap = (Scope, Map.Map Lang Scope)

-- | Add the following fields to state:
--   * stateGeneralTypedefs           :: GMap Int MVar Scope
--   * stateConcreteTypedefs          :: GMap Int MVar (Map Lang Scope)
collectTypes :: DAG MVar [AliasedSymbol] ExprI -> MorlocMonad ()
collectTypes fullDag = do
  let typeDag = DAG.mapEdge (\xs -> [(x, y) | AliasedType x y <- xs]) fullDag
  result <- DAG.synthesizeNodes formTypes typeDag
  case result of
    Nothing -> MM.throwError (CyclicDependency "stalled in collectTypes")
    Just _ -> return ()
  where
    formTypes ::
      MVar ->
      ExprI ->
      [ ( MVar -- child module name
        , [(TVar, TVar)] -- alias map
        , GCMap
        )
      ] ->
      MorlocMonad GCMap
    formTypes m e0 childImports = do

      let (generalTypemap, concreteTypemapsIncomplete) = foldl inherit (AST.findTypedefs e0) childImports

      -- Here we are creating links from every indexed term in the module to the module
      -- sources and aliases. When the module abstractions are factored out later,
      -- this will be the only way to access module-specific info.
      let indices = AST.getIndices e0

      -- link concrete records to their full general forms
      let concreteTypemaps = Map.map (completeRecords generalTypemap) concreteTypemapsIncomplete

      s <- MM.get
      MM.put
        ( s
            { stateGeneralTypedefs = GMap.insertMany indices m generalTypemap (stateGeneralTypedefs s)
            , stateConcreteTypedefs = GMap.insertMany indices m concreteTypemaps (stateConcreteTypedefs s)
            }
        )

      return (generalTypemap, concreteTypemaps)

    inherit :: GCMap -> (key, [(TVar, TVar)], GCMap) -> GCMap
    inherit (thisGmap, thisCmap) (_, links, (gmap, cmap)) =
      let gmap' = filterAndSubstitute links gmap
          cmap' = Map.map (filterAndSubstitute links) cmap
       in ( Map.unionWith mergeEntries gmap' thisGmap
          , Map.unionWith (Map.unionWith mergeEntries) cmap' thisCmap
          )


-- | collect type definitions globally
--   define:
--     * stateUniversalGeneralTypedefs
--     * stateUniversalConcreteTypedefs
collectUniversalTypes :: MorlocMonad ()
collectUniversalTypes = do

  universalGeneralScope <- getUniversalGeneralScope
  universalConcreteScope <- getUniversalConcreteScope universalGeneralScope

  s <- MM.get
  MM.put
    ( s
        { stateUniversalGeneralTypedefs = universalGeneralScope
        , stateUniversalConcreteTypedefs = universalConcreteScope
        }
    )
  where

    getUniversalGeneralScope :: MorlocMonad Scope
    getUniversalGeneralScope = do
      (GMap _ (Map.elems -> scopes)) <- MM.gets stateGeneralTypedefs
      return $ Map.unionsWith mergeEntries scopes

    getUniversalConcreteScope :: Scope -> MorlocMonad (Map.Map Lang Scope)
    getUniversalConcreteScope gscope = do
      (GMap _ modMaps) <- MM.gets stateConcreteTypedefs
      let langs = unique $ concatMap Map.keys . Map.elems $ modMaps
      scopes <- mapM getLangScope langs
      return . Map.fromList $ zip langs scopes
      where
        getLangScope :: Lang -> MorlocMonad Scope
        getLangScope lang = do
          (GMap _ (Map.elems -> langMaps)) <- MM.gets stateConcreteTypedefs
          -- See note above, here we are completing any incomplete concrete
          -- record/table/object types
          let langMaps' = map (Map.map (completeRecords gscope)) langMaps
          return . Map.unionsWith mergeEntries . mapMaybe (Map.lookup lang) $ langMaps'


-- | links the general entries from records to their abbreviated concrete cousins.
-- For example:
--   record (Person a) = Person {name :: Str, info a}
--   record Py => Person a = "dict"
-- This syntax avoids the need to duplicate the entire entry
completeRecords :: Scope -> Scope -> Scope
completeRecords gscope = Map.mapWithKey (completeRecord gscope)
  where
  completeRecord ::
    Scope ->
    TVar ->
    [([Either TVar TypeU], TypeU, ArgDoc, Bool)] ->
    [([Either TVar TypeU], TypeU, ArgDoc, Bool)]
  completeRecord g v xs = case Map.lookup v g of
    (Just ys) -> map (completeValue [(vs, t) | (vs, t, _, _) <- ys]) xs
    Nothing -> xs

  completeValue ::
    [([Either TVar TypeU], TypeU)] ->
    ([Either TVar TypeU], TypeU, ArgDoc, Bool) ->
    ([Either TVar TypeU], TypeU, ArgDoc, Bool)
  completeValue ((vs, NamU _ _ ps rs) : _) (_, NamU o v _ [], d, terminal) = (vs, NamU o v ps rs, d, terminal)
  completeValue _ x = x




-- merge type functions, names of generics do not matter
mergeEntries ::
  [([Either TVar TypeU], TypeU, ArgDoc, Bool)] ->
  [([Either TVar TypeU], TypeU, ArgDoc, Bool)] ->
  [([Either TVar TypeU], TypeU, ArgDoc, Bool)]
mergeEntries xs0 ys0 = filter (isNovel ys0) xs0 <> ys0
  where
    isNovel ::
      [([Either TVar TypeU], TypeU, ArgDoc, Bool)] -> ([Either TVar TypeU], TypeU, ArgDoc, Bool) -> Bool
    isNovel [] _ = True
    isNovel ((vs2, t2, _, isTerminal1) : ys) x@(vs1, t1, _, isTerminal2)
      | (length vs1 == length vs2)
          && t1 == foldl (\t (v1, v2) -> rename v2 v1 t) t2 [(v1, v2) | (Left v1, Left v2) <- zip vs1 vs2]
          && isTerminal1 == isTerminal2 =
          False
      | otherwise = isNovel ys x

-- clean imports
--   * only keep the exports of a module that are explicitly imported
--   * resolve any aliases
filterAndSubstitute :: [(TVar, TVar)] -> Scope -> Scope
filterAndSubstitute links typemap =
  let importedTypes = Map.filterWithKey (\k _ -> k `elem` map fst links) typemap
   in foldl typeSubstitute importedTypes links
  where
    typeSubstitute ::
      Scope -> -- imported map
      (TVar, TVar) -> -- source name and local alias
      Scope -- renamed map
    typeSubstitute typedefs (sourceName, localAlias) =
      case Map.lookup sourceName typedefs of
        (Just xs) ->
          Map.insert
            localAlias
            (map (\(a, b, c, d) -> (a, rename sourceName localAlias b, c, d)) xs)
            (Map.delete sourceName typedefs)
        Nothing -> typedefs

collectSources :: DAG MVar [AliasedSymbol] ExprI -> MorlocMonad ()
collectSources fullDag = do
  _ <- DAG.mapNodeWithKeyM linkSources fullDag
  return ()
  where
    linkSources :: MVar -> ExprI -> MorlocMonad ExprI
    linkSources m e0 = do
      let objSources = AST.findSources e0
      let indices = AST.getIndices e0
      s <- MM.get
      MM.put (s {stateSources = GMap.insertManyWith (<>) indices m objSources (stateSources s)})
      return e0

-- Rename a variable. For example:
--   import maps (Map as HashMap, foo, bar)
--
-- Here all uses `Map` in anything imported from `maps` needs to
-- be renamed to `HashMap`. So we call:
--   rename (TV "Map") (TV "HashMap") x
-- where `x` is any term
rename :: TVar -> TVar -> TypeU -> TypeU
rename sourceName localAlias = f
  where
    f (VarU v)
      | v == sourceName = VarU localAlias
      | otherwise = VarU v
    f (ExistU v (ps, o1) (rs, o2)) =
      let v' = if v == sourceName then localAlias else v
       in ExistU v' (map f ps, o1) (map (second f) rs, o2)
    f (ForallU v t) = ForallU v (f t)
    f (FunU ts t) = FunU (map f ts) (f t)
    f (AppU t ts) = AppU (f t) (map f ts)
    f (NamU o v ts rs) =
      let v' = if v == sourceName then localAlias else v
      in NamU o v' (map f ts) (map (second f) rs)
